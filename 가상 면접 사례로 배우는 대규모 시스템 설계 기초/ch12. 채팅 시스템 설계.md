## 12. 채팅 시스템 설계

### **개략적 설계안 제시 및 동의 구하기**

1. 클라이언트들로 부터 메시지 수신
2. 메시지 수신자 결정 및 전달
3. 수신자가 접속 상태가 아닌 경우에는 접속할 때 까지 해당 메시지 보관

![image](https://github.com/taeyun1215/BookReview/assets/65766105/e0ba0b39-4603-4969-8a84-f41401ec823d)

- **송신 프로토콜: HTTP 프로토콜과 keep-alive 헤더**
    - **HTTP 프로토콜**은 메시지 송신 클라이언트가 서버에 메시지를 보낼 때 사용했다.
    - 이 프로토콜은 웹 기반 통신의 기초이며, 오랜 시간 동안 널리 사용됐다.
    - **keep-alive 헤더**를 사용해서 클라이언트와 서버 사이의 연결을 지속적으로 유지할 수 있었으며, 이는 TCP 연결 설정 과정에서 발생하는 핸드셰이크(handshake) 횟수를 줄이는 데 도움이 됐다.

### **수신 프로토콜: 폴링, 롱 폴링, 웹소켓**

1. **폴링(Polling)**
    - 클라이언트가 주기적으로 서버에게 새 메시지의 존재 여부를 물어보는 방식이었다.
    - 단점: 새 메시지가 없음에도 불구하고 서버 자원이 낭비될 수 있었다.
2. **롱 폴링(Long Polling)**
    - 클라이언트는 서버로부터 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지했다. 새 메시지를 받으면 기존 연결을 종료하고 새로운 요청을 보내어 절차를 다시 시작했다.
    - 단점: 서버 로드 밸런싱이나 연결 해제 여부 파악 등의 문제가 발생할 수 있었으며, 여전히 비효율적일 수 있었다.
3. **웹소켓(WebSocket)**

    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/f311414c-65f1-4311-b2df-9e3f5fc4c61a)
    
    - 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용되는 기술이었다. 클라이언트가 연결을 시작하고, 한 번 설정된 연결은 지속적이며 양방향이었다.
    - 웹소켓은 처음에 HTTP 연결을 통해 시작되지만, 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드 됐다. 이는 HTTP 프로토콜을 사용할 때 발생할 수 있는 일부 제한을 극복할 수 있게 해줬다.
    
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/e3fd5abe-afe5-4620-a312-69f5092136ec)
    
    ### **개략적 설계안**
    
    - **Stateless (무상태)**
        - **서비스 예시:** 로그인, 회원가입, 사용자 프로필 조회 등
        - **특징:** 서비스는 클라이언트의 상태 정보를 저장하지 않습니다. 각 요청은 독립적이며, 모든 필요한 정보는 요청과 함께 전달되어야 합니다. 서버는 요청을 받았을 때 이전의 상호작용이나 상태를 기억하지 않는다.
        - **이점:** 서비스의 확장성과 유연성이 높아집니다. 로드밸런서를 사용하여 요청을 여러 서버에 분산시킬 수 있으며, 각 요청은 어떤 서버에서도 독립적으로 처리될 수 있다. 이는 모놀리식 아키텍처 또는 마이크로서비스 아키텍처 모두에 적용될 수 있다.
    - **Stateful (유상태)**
        - **서비스 예시:** 채팅
        - **특징:** 서비스는 클라이언트의 상태 정보를 유지하며, 클라이언트와 서버 사이에 지속적인 연결이 필요하다. 이 연결을 통해 클라이언트의 상태가 서버에 저장되며, 클라이언트는 서버와의 연결이 유지되는 한 동일한 서버에 연결된다.
        - **이점:** 복잡한 상호작용이나 지속적인 정보 교환을 필요로 하는 애플리케이션에서 유용하다. 예를 들어, 실시간 채팅이나 온라인 게임에서 사용자 간의 연속적인 상호작용을 관리할 수 있다.
        - **service discovery:** 유상태 서비스에서는 클라이언트가 처음 연결할 서버를 찾기 위해 서비스 디스커버리가 필요하다. 이 서비스는 클라이언트에게 접속할 채팅 서버의 DNS 호스트명을 알려준다. 또한, 특정 서버에 과부하가 생기지 않도록 부하 분산을 관리하는 역할도 한다.
    - **Stateless vs Stateful 차이**
        - **상태 정보 저장:** Stateless 서비스는 상태 정보를 저장하지 않으며, 모든 요청이 독립적이다. 반면, Stateful 서비스는 사용자의 상태 정보를 서버가 유지하며, 클라이언트와 서버 간의 지속적인 연결을 필요로 한다.
        - **확장성:** Stateless 서비스는 상태 정보를 서버에 저장하지 않기 때문에 확장성이 더 높고 관리가 용이하다. Stateful 서비스는 상태 정보를 관리해야 하기 때문에 확장성과 관리 측면에서 더 복잡할 수 있다.
        - **용도:** Stateless 서비스는 간단한 요청/응답 패턴의 작업에 적합하며, Stateful 서비스는 지속적인 상태 정보와 상호작용이 필요한 애플리케이션에 적합다.
    - **푸시 알림의 작동 방식**
        - **알림 생성:** 서버 또는 애플리케이션에서 발생한 특정 이벤트(예: 새 메시지 도착, 업데이트 발표 등)가 푸시 알림을 생성한다.
        - **서드파티 푸시 알림 서비스:** 알림은 서드파티 푸시 알림 서비스(예: Firebase Cloud Messaging(FCM) for Android, Apple Push Notification Service(APNS) for iOS)를 통해 관리된다. 이 서비스들은 알림을 사용자의 디바이스로 전달하는 역할을 한다.
        - **알림 전달:** 푸시 알림 서비스는 알림을 해당 사용자의 디바이스에 전달한다. 이 과정은 앱이 백그라운드에 있거나 완전히 종료된 상태에서도 이루어진다.
        - **사용자 인터랙션:** 사용자는 디바이스의 알림을 통해 새로운 이벤트나 정보를 받게 되며, 이 알림을 탭하여 앱을 열거나, 더 많은 정보를 볼 수 있다.
    - 규모 확장성

      ![image](https://github.com/taeyun1215/BookReview/assets/65766105/cd9ff8e6-f73b-41b9-960d-54a26bf34d76)
