## 12. 채팅 시스템 설계

### **개략적 설계안 제시 및 동의 구하기**

1. 클라이언트들로 부터 메시지 수신
2. 메시지 수신자 결정 및 전달
3. 수신자가 접속 상태가 아닌 경우에는 접속할 때 까지 해당 메시지 보관

![image](https://github.com/taeyun1215/BookReview/assets/65766105/e0ba0b39-4603-4969-8a84-f41401ec823d)

- **송신 프로토콜: HTTP 프로토콜과 keep-alive 헤더**
    - **HTTP 프로토콜**은 메시지 송신 클라이언트가 서버에 메시지를 보낼 때 사용했다.
    - 이 프로토콜은 웹 기반 통신의 기초이며, 오랜 시간 동안 널리 사용됐다.
    - **keep-alive 헤더**를 사용해서 클라이언트와 서버 사이의 연결을 지속적으로 유지할 수 있었으며, 이는 TCP 연결 설정 과정에서 발생하는 핸드셰이크(handshake) 횟수를 줄이는 데 도움이 됐다.

### **수신 프로토콜: 폴링, 롱 폴링, 웹소켓**

1. **폴링(Polling)**
    - 클라이언트가 주기적으로 서버에게 새 메시지의 존재 여부를 물어보는 방식이었다.
    - 단점: 새 메시지가 없음에도 불구하고 서버 자원이 낭비될 수 있었다.
2. **롱 폴링(Long Polling)**
    - 클라이언트는 서버로부터 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지했다. 새 메시지를 받으면 기존 연결을 종료하고 새로운 요청을 보내어 절차를 다시 시작했다.
    - 단점: 서버 로드 밸런싱이나 연결 해제 여부 파악 등의 문제가 발생할 수 있었으며, 여전히 비효율적일 수 있었다.
3. **웹소켓(WebSocket)**

    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/f311414c-65f1-4311-b2df-9e3f5fc4c61a)
    
    - 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용되는 기술이었다. 클라이언트가 연결을 시작하고, 한 번 설정된 연결은 지속적이며 양방향이었다.
    - 웹소켓은 처음에 HTTP 연결을 통해 시작되지만, 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드 됐다. 이는 HTTP 프로토콜을 사용할 때 발생할 수 있는 일부 제한을 극복할 수 있게 해줬다.
    
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/e3fd5abe-afe5-4620-a312-69f5092136ec)
    
    ### **개략적 설계안**
    
    - **Stateless (무상태)**
        - **서비스 예시:** 로그인, 회원가입, 사용자 프로필 조회 등
        - **특징:** 서비스는 클라이언트의 상태 정보를 저장하지 않습니다. 각 요청은 독립적이며, 모든 필요한 정보는 요청과 함께 전달되어야 합니다. 서버는 요청을 받았을 때 이전의 상호작용이나 상태를 기억하지 않는다.
        - **이점:** 서비스의 확장성과 유연성이 높아집니다. 로드밸런서를 사용하여 요청을 여러 서버에 분산시킬 수 있으며, 각 요청은 어떤 서버에서도 독립적으로 처리될 수 있다. 이는 모놀리식 아키텍처 또는 마이크로서비스 아키텍처 모두에 적용될 수 있다.
    - **Stateful (유상태)**
        - **서비스 예시:** 채팅
        - **특징:** 서비스는 클라이언트의 상태 정보를 유지하며, 클라이언트와 서버 사이에 지속적인 연결이 필요하다. 이 연결을 통해 클라이언트의 상태가 서버에 저장되며, 클라이언트는 서버와의 연결이 유지되는 한 동일한 서버에 연결된다.
        - **이점:** 복잡한 상호작용이나 지속적인 정보 교환을 필요로 하는 애플리케이션에서 유용하다. 예를 들어, 실시간 채팅이나 온라인 게임에서 사용자 간의 연속적인 상호작용을 관리할 수 있다.
        - **service discovery:** 유상태 서비스에서는 클라이언트가 처음 연결할 서버를 찾기 위해 서비스 디스커버리가 필요하다. 이 서비스는 클라이언트에게 접속할 채팅 서버의 DNS 호스트명을 알려준다. 또한, 특정 서버에 과부하가 생기지 않도록 부하 분산을 관리하는 역할도 한다.
    - **Stateless vs Stateful 차이**
        - **상태 정보 저장:** Stateless 서비스는 상태 정보를 저장하지 않으며, 모든 요청이 독립적이다. 반면, Stateful 서비스는 사용자의 상태 정보를 서버가 유지하며, 클라이언트와 서버 간의 지속적인 연결을 필요로 한다.
        - **확장성:** Stateless 서비스는 상태 정보를 서버에 저장하지 않기 때문에 확장성이 더 높고 관리가 용이하다. Stateful 서비스는 상태 정보를 관리해야 하기 때문에 확장성과 관리 측면에서 더 복잡할 수 있다.
        - **용도:** Stateless 서비스는 간단한 요청/응답 패턴의 작업에 적합하며, Stateful 서비스는 지속적인 상태 정보와 상호작용이 필요한 애플리케이션에 적합다.
    - **푸시 알림의 작동 방식**
        - **알림 생성:** 서버 또는 애플리케이션에서 발생한 특정 이벤트(예: 새 메시지 도착, 업데이트 발표 등)가 푸시 알림을 생성한다.
        - **서드파티 푸시 알림 서비스:** 알림은 서드파티 푸시 알림 서비스(예: Firebase Cloud Messaging(FCM) for Android, Apple Push Notification Service(APNS) for iOS)를 통해 관리된다. 이 서비스들은 알림을 사용자의 디바이스로 전달하는 역할을 한다.
        - **알림 전달:** 푸시 알림 서비스는 알림을 해당 사용자의 디바이스에 전달한다. 이 과정은 앱이 백그라운드에 있거나 완전히 종료된 상태에서도 이루어진다.
        - **사용자 인터랙션:** 사용자는 디바이스의 알림을 통해 새로운 이벤트나 정보를 받게 되며, 이 알림을 탭하여 앱을 열거나, 더 많은 정보를 볼 수 있다.
    - 규모 확장성
    
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/8d3feaac-9fdd-461c-b5b3-e496ca8bf048)
    
    - 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
    - 접속 상태 서버는 사용자의 접속 여부를 관리한다.
    - API 서버는 로그인, 회원가입, 프로필 변경등 그 외 나머지 전부를 처리한다.
    - 알림 서버는 푸시 알림을 보낸다.
    - 키-값 저장소에 채팅 이력을 보관한다.

- 저장소 선택
    - 고려사항
        - 데이터 유형과 읽기/쓰기 연산 패턴: 채팅 시스템에서 다루는 데이터의 유형과 읽기/쓰기 연산의 패턴을 고려해야 한다.
    - 데이터 유형
        1. 일반적인 데이터: 사용자 프로필, 설정, 친구 목록 등. 이 데이터는 안정성을 보장하는 관계형 데이터베이스에 보관한다.
        2. 채팅 이력 데이터: 페이스북 메신저나 왓츠앱처럼 매일 600억 개의 메시지를 처리하는 등 대규모의 데이터를 다룬다. 이 데이터는 NoSQL 데이터베이스에 보관한다.
    - 읽기/쓰기 연산 패턴
        - 대부분의 사용자는 최근 메시지를 주로 보며, 오래된 메시지는 잘 보지 않는다.
        - 그러나 검색 기능, 특정 사용자가 언급된 메시지 보기, 특정 메시지로 점프하는 등 무작위 데이터 접근이 필요하다.
        - 1:1 채팅 앱에서는 읽기:쓰기 비율이 대략 1:1이다.
    - NoSQL 선택한 이유
        - 수평적 규모 확장이 쉽다: 키/값 저장소를 사용하면 규모 확장이 용이하다.
        - 데이터 접근 지연시간이 낮다: 채팅 시스템에서는 빠른 데이터 접근이 중요하다.
        - 롱 테일 데이터 처리: 관계형 데이터베이스는 롱 테일에 해당하는 데이터 처리에 비효율적일 수 있다. NoSQL은 이를 더 잘 처리한다.
        - 예시: 페이스북 메신저는 HBase, 디스코드는 카산드라 NoSQL을 사용한다.
- 데이터 모델
    - 1:1 채팅 메시지 테이블
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/3ba1849c-239c-4965-a320-7367db060786)
        
        - 기본 키: `message_id`
        - 속성: 메시지 ID, 발신자 ID, 수신자 ID, 내용, 생성 시각
        - 메시지 ID: 고유하며, 정렬 가능하고 시간 순서와 일치해야 한다. NoSQL에서는 스노플레이크 같은 전역적 순서 번호 생성기 또는 지역적 순서 번호 생성기를 사용한다.
    - 그룹 채팅 메시지 테이블
        - 기본 키: `(channel_id, message_id)` 복합 키
        - 속성: 채널 ID, 메시지 ID, 내용, 생성 시각
        - 채널 ID: 그룹 채팅을 구분하는 키로, 파티션 키로도 사용된다.
- 이렇게 데이터베이스 선택과 데이터 모델은 채팅 시스템의 성능과 확장성을 결정짓는 중요한 요소다.
- NoSQL의 선택은 대규모 데이터 처리와 빠른 접근 시간, 그리고 수평적 확장성을 제공하여 현대의 대규모 실시간 채팅 시스템 요구사항을 만족시킨다.

### 상세 설계

- 서비스 탐색 (Service Discovery)
    
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/2842e39e-9d0a-4975-a126-7a79bc68db49)
    
    - 서비스 탐색은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 역할을 한다.
    - 기준으로는 클라이언트의 위치(geographical location)와 서버의 용량(capacity) 등이 있다.
    - 아파치 주키퍼(Apache Zookeeper)와 같은 오픈 소스 솔루션을 사용하여, 사용 가능한 모든 채팅 서버를 등록해 두고 클라이언트가 접속 시도 시, 사전에 정한 기준에 따라 최적의 채팅 서버를 선택한다.
    - 동작 과정은 다음과 같다.
        1. 사용자 A가 시스템에 로그인을 시도한다.
        2. 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보낸다.
        3. API 서버가 사용자 인증을 처리한 후, 서비스 탐색 기능이 동작하여 해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.
        4. 사용자 A는 최적의 채팅 서버와 웹소켓 연결을 맺는다.
- 메시지 흐름
    - 1:1 채팅 메시지 처리
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/6136942e-c4a7-4e9d-816d-076d766f527d)

        1. 사용자 A가 채팅 서버 1로 메시지 전송한다.
        2. 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID를 결정한다.
        3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송한다.
        4. 메시지는 키-값 저장소에 보관된다.
            - 사용자 B가 접속 중인 경우, 메시지는 사용자 B가 접속 중인 채팅 서버로 전송된다.
            - 사용자 B가 접속 중이 아니라면, 푸시 알림 메시지를 푸시 알림 서버로 보낸다.
        5. 채팅 서버 2는 메시지를 사용자 B에게 전송한다.
    - 여러 단말 사이의 메시지 동기화
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/89051e9e-55d2-4e03-bede-bd83e94605a7)

        - 각 단말은 `cur_max_message_id` 변수를 유지하여 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적한다.
        - 새 메시지로 간주하는 조건:
            - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
            - 메시지 ID가 `cur_max_message_id`보다 크다.
    - 소규모 그룹 채팅
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/003d365c-8645-4203-90ba-f8ff16dfc4af)
        
        - 사용자 A가 보낸 메시지는 사용자 B와 C의 메시지 동기화 큐에 복사된다.
        - 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되므로 메시지 동기화 플로우가 단순하다.
        - 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는다.
- 사용자 접속 상태 표시
    - 로그인
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/f2f0413b-ccd6-4de6-a7cd-186e4dd06a4b)

        - 클라이언트와 실시간 서비스 사이에 웹 소켓 연결이 맺어지면, 접속 상태 서버는 사용자의 상태와 `last_active_at` 타임스탬프 값을 키-값 저장소에 보관한다.
    - 로그아웃
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/daab4b1d-20cb-4da7-a8ab-e9f5c8231e27)
        
        - 사용자가 로그아웃시 할 때, API는 접속 상태 서버에 정보를 전달하며 키-값 저장소에 있는 사용자 상태 정보를 offline으로 변경한다. 이 변경은 사용자의 UI 상태를 접속 중이 아닌 것으로 표시하게 만든다.
    - 접속 장애
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/934368d9-5466-43cf-bdfb-085ce38f2797)

        - 인터넷 연결은 항상 안정적이지 않아 잠깐의 연결 끊김이 발생할 수 있다. 예를 들어, 사용자가 터널을 통과하는 동안 잠깐 연결이 끊길 수 있다.
        - 이러한 장애에 대응하기 위해, heartbeat 검사를 통해 사용자의 접속 상태를 관리할 수 있다.
        - 온라인 상태의 클라이언트는 주기적으로 heartbeat event를 접속상태 서버로 보내며, 마지막 이벤트를 받은 지 정해진 시간(x초) 이내에 다시 heartbeat event를 받으면 해당 사용자의 접속 상태를 온라인으로 유지한다. 그렇지 않을 경우, 사용자의 상태를 오프라인으로 변경한다.
    - 상태 정보의 전송
        
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/94f0359b-505c-4131-882d-993b2e53224e)
        
        - 상태 정보 서버는 publish-subscribe 모델을 사용하여 각 친구 관계마다 채널을 하나씩 둔다. 예를 들어, 사용자 A의 접속 상태가 변경되면 A와 친구 관계에 있는 B, C, D 등의 채널에 상태 변경 정보를 전파한다.
        - 이 방식은 그룹의 크기가 작을 때 효과적이다. 그러나 그룹 크기가 커지면 상태 변화 알림에 따른 비용과 시간이 많이 들게 되므로, 큰 그룹에서는 상태 정보를 효율적으로 관리하기 위한 다른 접근 방법이 필요하다.
        - 예를 들어, 10만 명의 사용자가 있는 채팅 그룹에서 상태 변화 하나당 10만 개의 이벤트 메시지가 발생할 수 있다. 이를 해결하기 위해, 사용자가 그룹에 입장할 때만 상태 정보를 읽거나, 친구 리스트의 접속 상태를 갱신하고 싶을 때 수동으로 갱신하도록 유도할 수 있다.

### 마무리

- 기본 아키텍처 구성 요약
    - 실시간 메시징: 클라이언트와 서버 사이의 실시간 통신을 가능하게 하는 웹소켓을 사용한다.
    - 컴포넌트 설계: 채팅 서버, 접속상태 서버, 푸시 알람 서버, 채팅 이력 보관용 키-값 저장소, 그리고 나머지 기능을 담당하는 API 서버 등 다양한 컴포넌트를 설계한다.
- 확장 기능
    - 미디어 파일 지원
        - 미디어 파일의 용량이 크기 때문에 압축, 클라우드 저장소 사용, 섬네일 생성 등을 고려한다.
    - 종단 간 암호화
        - 왓츠앱과 같이 메시지 전송에 종단 간 암호화를 지원하여, 메시지 발신인과 수신자 이외에는 아무도 메시지를 볼 수 없도록 한다.
    - 캐시
        - 이미 읽은 메시지를 캐시하여 서버와 주고받는 데이터 양을 줄이고, 로딩 속도를 개선한다.
    - 로딩 속도 개선
        - 슬랙처럼 사용자 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선한다.
- 오류 처리
    - 채팅 서버 오류
        - 채팅 서버 하나에 수십만 사용자가 접속해 있는 상황에서 서버 하나가 문제를 겪으면, 서비스 탐색 기능(예: 아파치 주키퍼)이 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 해야 한다.
    - 메시지 재전송
        - 재시도(retry)나 큐(queue)를 사용하여 메시지의 안정적인 전송을 보장한다.
