## 10. 알림 시스템 설계

### **문제 이해 및 설계 범위 확정**

- 알림 시스템은 고객에게 중요할만한 정보를 비동기적으로 제공한다.
- 같은 고객에 대해서 너무 많은 알림을 발송하는 경우 피로감을 줄 수 있기 때문에 알림 수신을 거부할 수 있기 때문에 유저마다 적절한 알림 횟수로 제한해야 한다.
- 서비스의 규모와 특성에 따라 대량의 트래픽을 발생시킬 수 있기 때문에 주의해야 한다.
- 크게 푸시 알림, SMS 메시지, e-mail 알림으로 분류할 수 있다.

### **개략적인 설계안 제시 및 동의 구하기**

- **알림 유형별 지원 방안**
    - **iOS 푸시 알림**
        - iOS에서 푸시 알림을 보내기 위해서는 세 가지 주요 컴포넌트가 필요하다:
            1. **알림 제공자**: 알림 요청을 생성하여 애플 푸시 알림 서비스(APNS)로 보내는 역할을 한다. 이 과정에서 단말토큰과 페이로드 데이터가 필요하다.
            2. **APNS (Apple Push Notification Service)**: 애플이 제공하는 원격 서비스로, 알림 제공자로부터 받은 요청을 iOS 장치로 전송한다.
            3. **iOS 단말기**: 사용자의 iOS 장치는 APNS로부터 푸시 알림을 수신한다.
    - **안드로이드 푸시 알림**
        - 안드로이드에서의 푸시 알림 전송 절차는 iOS와 유사하지만, APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다:
            1. **알림 제공자**: 알림을 생성하여 FCM으로 보내는 역할을 한다.
            2. **FCM (Firebase Cloud Messaging)**: 구글이 제공하는 서비스로, 알림 제공자로부터 알림을 받아 안드로이드 장치로 전송한다.
            3. **안드로이드 단말기**: 사용자의 안드로이드 장치는 FCM으로부터 푸시 알림을 수신한다.
    - **SMS 메시지**
        - SMS 메시지는 트윌리오, 넥스모, 뿌리오, 알리고 등 제 3 사업자의 서비스를 통해 전송된다.
        - 이러한 서비스는 네이버, NHN, 가비아 등 다양한 제공자를 통해 제공되며, 알림 제공자가 SMS 서비스를 이용해 최종 사용자의 단말로 메시지를 보낼 수 있게 한다.
    - **이메일**
        - 이메일 전송은 회사에서 직접 구축한 메일 서버나 AWS의 SES(Simple Email Service), 메일침프(Mailchimp), Sendgrid 등의 서비스를 통해 이루어진다.
        - 이메일 서비스 제공자는 알림 제공자로부터 이메일 요청을 받아 최종 사용자의 이메일 수신 단말로 전송한다.
- 초안 설계 구조
  
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/7d210475-db11-44c7-b0ba-c225250b4013)
  
    - 서비스 1 ~ 서비스 N
        - 마이크로서비스
        - 크론잡
        - 분산 시스템 컴포넌트
        - ex) 과금 서비스(납기일 알림), 쇼핑몰 웹사이트(배송 알림)
    - 알림 서버
        - 서비스들에게 알림을 전송할 수 있는 API 제공
        - 정해진 형식에 따라 알림 메시지 생성
            - 캐시 / 데이터베이스에 질의하여 알림에 포함 시킬 데이터를 가져옴
        - 메시지 큐로 알림 전달
    - 캐시 / 데이터베이스
        - 알림에 포함시킬 메타 데이터 등을 저장
        - 캐시 : 사용자 정보, 단말 정보 등을 캐시
        - 데이터베이스 : 사용자, 알림 등에 대한 다양한 정보 저장
    - 메시지 큐
        - iOS 푸시 알림 큐, 안드로이드 푸시 알림 큐, SMS 큐, 이메일 큐
        - 시스템 컴포넌트 간 의존성 제거
        - 알림 메시지에 대한 버퍼 역할
    - 작업 서버
        - 메시지 큐에서 알림을 꺼내서 제3자 제공 서비스로 전달
        - 오류 발생 시 재시도
    - 제3자 제공 서비스
        - 실제 단말로 알림 전송
            - APNS : iOS 장치로 푸시 알림을 보내는 애플의 원격 서비스
            - FCM : 안드로이드의 푸시 알림 서비스
            - SMS 서비스 : 문자 메시지 전송 서비스 (Twilio, Nexmo 등)
            - 이메일 서비스 : 데이터 분석(Analytics) 서비스도 함께 제공 (Sendgrid, Mailchimp 등)
    - **초안의 문제점**
        - SPOF(Single-Point-Of-Failure) : 알림 서비스에 서버가 하나만 있으면 그 서버에 장애가 생겼을 경우 전체 서비스의 장애로 이어질 수 있다.
        - 규모 확장성 : 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
        - 성능 병목 : 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다. 예를 들어 HTML 페이지를 만들고 제3자 서비스의 응답을 기다리는 일은 시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.
- 개선안

    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/dec62bc5-47ca-4869-ad93-b79a97e36a63)
    
    - 알림이 전송되는 과정
        1. API를 호출하여 알림 서버로 알림을 보낸다.
        2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
        3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.
        4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
        5. 작업 서버는 알림을 제3자 서비스로 보낸다.
        6. 제3자 서비스는 사용자 단말로 알림을 전송한다.
    - **데이터베이스와 캐시의 분리**
        - 알림 시스템에서 데이터베이스와 캐시를 분리하는 것은 I/O 부하를 줄이고 시스템의 전체 성능을 향상시키는 핵심 전략이다.
        - 캐싱된 알림 템플릿 데이터가 거대한 경우, 압축 전략을 통해 저장되는 데이터의 양을 줄임으로써 네트워크 I/O 부하를 감소시키는 동시에 CPU 사용을 최적화한다.
        - 이러한 CPU 인텐시브한 설계는 알림 서비스의 수평 확장을 용이하게 한다.
    - **메시지 큐의 활용**
        - 메시지 큐를 사용하는 것은 시스템 컴포넌트 사이의 강한 결합을 끊어내고, 다량의 알림 발송 시 버퍼 역할을 하는 등 여러 장점을 제공한다.
        - 특히, 제3자 서비스별로 메시지 큐를 분리함으로써, 한 서비스의 장애가 시스템 전체에 영향을 미치는 것을 방지한다. 이는 장애 대응력을 높이고, 시스템의 안정성을 강화한다.
        - 작업 서버는 메시지 큐에서 메시지를 소비하여(consume) 제3자 서비스로 전달하는 역할을 한다.
        - 또한, 작업 서버는 알림 로그 데이터베이스를 관리하고, 발송 실패에 대한 재시도 메커니즘을 구현하여, 한 번 전송되었던 알림의 중복 전송 빈도를 줄일 수 있다.
    - **알림 서버의 규모 확장성**
        - 알림 서버는 상태를 유지하지 않는(Stateless) 방식으로 설계되어, 자동 수평 규모 확장이 가능하다.
        - 이는 시스템에 부하가 증가하더라도 유연하게 대응할 수 있게 하며, 제3자 서비스의 장애가 전체 장애로 이어지지 않도록 한다.
    - **메시지 큐 구성 전략**
        - 알림 종류마다 별도의 메시지 큐를 구성하는 것은 장애 분리와 서비스별 관리의 용이성을 목적으로 한다.
        - 하지만, 이는 관리해야 할 컴포넌트의 수를 증가시키는 단점도 있다. 대안으로, 단일 메시지 큐 내에서 여러 토픽을 구분하여 사용하는 방식도 고려될 수 있다.
        - 이 경우, 장애 발생 시 영향을 최소화하기 위해 알림 실패 재시

### **상세 설계**

- 데이터 손실 방지
    - 알림 시스템 설계 시 안정성 확보와 데이터 손실 방지는 핵심 요소다.
    - 이를 위해 알림 데이터는 데이터베이스에 보관하며, 중복 전송을 최소화하고 재시도 메커니즘을 구현한다.
    - 이벤트 ID 검사를 통해 이미 전송된 알림의 중복을 방지하고, 필요한 경우 블룸 필터를 이용해 데이터베이스나 캐시 쿼리 전에 미리 확인한다.
- 재시도 방지
    - 사용자의 상세한 알림 설정을 허용하며, 각 알림 수단별 허용 여부를 체크해 필터링한다.
    - 제 3자 서비스의 전송 실패 시, 재시도 전용 큐를 이용해 알림을 재시도하며, 실패 횟수를 기록해 문제가 지속되면 개발자에게 알린다.
- 알림 설정
    - 큐 모니터링은 시스템의 건강 상태를 체크하는 중요한 과정이며, 쌓인 알림의 수를 모니터링해 처리 속도를 판단한다.
    - 이벤트 추적을 통해 알림의 효과를 분석하고, 사용자 경험을 개선하는 데 필수적인 데이터를 제공한다.
- 재시도 방법
    - 알림 템플릿을 사용하면 메시지 형식을 일관성 있게 유지하며, 오류 가능성을 줄이고 시간을 절약할 수 있다. 전송률 제한을 통해 사용자에게 과도한 알림을 보내는 것을 방지한다.
- 보안
    - 푸시 알림 전송 API는 인증된 클라이언트만 사용할 수 있도록 설정하여, 알림 시스템의 보안을 강화한다.
- 종합적으로, 알림 시스템은 데이터 손실 방지, 중복 전송 최소화, 사용자 설정의 유연성, 재시도 로직의 구현, 시스템 모니터링 및 보안 유지 등 다양한 요소를 고려하여 설계되어야 한다. 이를 통해 안정적이고 효율적인 알림 서비스를 제공할 수 있다.
- **설계 구조 보완**
  ![image](https://github.com/taeyun1215/BookReview/assets/65766105/0293db0b-9329-4f01-b65c-e0cd87fd10b3)
