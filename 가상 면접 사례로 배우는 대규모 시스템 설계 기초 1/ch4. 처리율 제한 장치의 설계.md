## 4. 처리율 제한 장치의 설계

네트워크 시스템에서 처리율 제한 장치(rate limiter)는 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치이다.

API 요청 횟수가 제한 장치에 정의된 임계치(threshould)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)된다.

- **장점**
    - Dos공격에 의한 자원 고갈을 방지 할 수 있다.
    - 비용을 절감한다. 서버를 많이 두지 않아도되고 우선 순위가 높은 API에 대한 더 많은 자원을 할당할 수 있다.API를 사용하고 있는 서비스의 경우 횟수 제한으로 인한 비용절감 효율이 증가한다.
    - 서버 과부하를 막는다. bot에서 오는 트래픽, 사용자의 잘못된 이용으로 인한 트래픽을 줄임으로 과부하를 막는다.

### 문제 이해 및 설계 범위 확정

면접관과 소통을 통해 어떤 제한 장치를 구현해야 하는지 분명히 함으로 처리율 제한 장치의 알고리즘을 선택 할 수 있다.

- 요구사항
    - 설정된 처리율을 초과하는 요청은 정확하게 제한한다
    - 낮은 응닫시간 : 이 처리율 제한 장치는 HTTP 응답시간에 나쁜 영향을 주어서는 곤란하다.
    - 적은 메모리
    - 분산형 처리율 제한 : 하나의 처리율 제한 장치를 여러 서버나 프로세스에 공유할 수 있어야 한다.
    - 예외 처리 : 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다.
    - 높은 결함 감내성 : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안 된다.
- 개략적 설계안 제시 및 동의 구하기
    - **클라이언트**
        - 클라이언트 요청은 쉽게 위변조가 가능해 처리율 제한을 안정적으로 걸 수 있는 환경이 아님
    - **서버**
        - API 서버가 처리율 제한 장치역할을 같이하는 경우
        - 처리율 제한 미들웨어를 만들어 API서버로 가는 요청을 통제하도록하는 경우 클라우드 마이크로서비스의 경우 해당 방식은 보통 API 게이트웨이라 불리는 컴포넌트에 구현
    - 미들웨어
        - MSA 인 경우, 처리율 제한 장치는 보통 API Gateway 에 구현한다.
        - API Gateway: 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등
- **처리율 제한 알고리즘**
    - 토큰 버킷
    - 누출 버킷(leaky bucket)
    - 고정 윈도 카운터(fixed window counter)
    - 이동 윈도 로그(sliding window log)
    - 이동 윈도 카운터(sliding window counter)

### 상세 설계

- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리되는가?
- **처리율 제한 규칙**
    - 마케팅 메시지의 최대치를 하루 5개로 제한
    - 분당 로그인 횟수를 5개로 제한
    - 리프트의 경우 다음과 같이 제한하며, 설정파일 형태로 디스크에 저장된다.
- **처리율 한도 초과 트래픽**
    - 한도 제한에 거릴 경우 HTTP 429 응답을 보낸다.
    - X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수
    - X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
    - X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야하는지 알림

![image](https://github.com/taeyun1215/BookReview/assets/65766105/af4a7f04-488b-43d6-8d42-f76818e22e3d)

1. 처리율 제한 규칙은 디스크에 보관, 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장
2. 클라이언트가 요청을 서버에 보내면 처리율 제한 미들웨어를 거침.
3. 미들웨어에서 제한 규칙을 캐시에서 가져옴. 아울러 카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져옴.
4. 가져온 값들에 근거하여 결정 내림.
    - 처리율 제한에 걸리지 않은 경우엔 API 서버로 보냄.
    - 처리율 제한에 걸렸다면 429 에러를 보낸다.

### **분산 환경에서의 처리율 제한 장치의 구현**

단일 서버를 지원하는 처리율 제한 장치를 구현하는 것은 어렵지 않지만, 여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제이다.

- 경쟁 조건
- 동기화

해결 방법

- 경쟁 조건
    - 레디스에서 카운터의 값을 읽는다.
    - counter +1 의 값이 임계치를 넘는지 본다.
    - 넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가시킨다.
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/78aa4bf6-38b7-43f4-867b-288f519c4109)

    - 경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 Lock(락)이다. 하지만 락은 시스템 성능을 떨어뜨림, 해결책으로는 두가지 방법이 있다.
        - 루아 스크립트
        - 정렬집합이라 불리는 레디스 자료구조
- 동기화 이슈
    - Sticky Session
    - Session Clustering
    - Redis Session
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/5543d121-e205-48bd-9f98-9847a03c62af)

        - Redis와 같은 중앙 집중형 데이터 저장소를 사용한다.

### 마무리

- 경성(hard) 또는 연성(soft) 처리율 제한경성
    - 임계치를 절대 넘어설 수 없다연성 = 잠시 임계치를 넘어설 수 있다.
- **다양한 계층에서의 처리율 제한**
    - 애플리케이션 계층(7번 계층)에서의 처리율 제한 외에도 다른 계층에서 제어
- 처리율 제한을 회피하는 방법
    - 클라이언트를 개선하여 처리율 개선
    - 캐시를 사용하여 호출 횟수 줄임
    - 임계치를 이해시키고, 많은 메시지를 보내지 않도록 한다.
    - 예외나 에러를 처리하는 코드로 예외인 상황에서 복구되도록
    - 재시도 로직을 구현할 때 충분한 백오프 시간을 둔다.
