### 가상 면접 사례로 배우는 대규모 시스템 설계 기초

## 사용자 수에 따른 규모 확장성
### 단일서버

웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.

<img src="https://github.com/taeyun1215/BookReview/assets/65766105/29bf8d3d-c286-4ea3-a241-4843afadcaf6" width="600">

1. 사용자는 도메인 이름을 이용하여 웹사이트에 접속한다. 이 접속을 위해서는 도메인 이름을 도메인 이름 서비스에 질의하여 IP 주소로 변환하는 과정이 필요하다.
2. DNS 조회로 웹 서버의 IP 주소가 반환된다.
3. 해당 IP 주소로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

### 데이터베이스
서버의 하나로는 충분하지 않아 여러 서버를 두어야 한다. 하나는 웹/모바일 트래픽 처리 용도고, 다른 하나는 데이터베이스용이다.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/647cd81d-b1a5-435a-95d3-cd410c91fa30" width="600">

**어떤 데이터베이스를 사용할 것인가?**

관계형 데이터베이스(Relational Database Management System, RDBMS)

- 종류 : MySQL, 오라클 데이터베이스, PostgreSQL
- **테이블**과 **열**과 **칼럼**으로 표현한다.
- **SQL** 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join) 하여 합칠 수 있다.

비-관계형 데이터베이스(NoSQL)

- 종류 : CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
    - 키-값(Key-value) 저장소
    - 그래프(graph) 저장소
    - 칼럼(column) 저장소
    - 문서(document) 저장소
- 일반적으로 조인 연산은 지원하지 않는다.
- 아래와 같은 경우에 비-관계형 데이터베이스가 바람직할 수도 있다.
    - 아주 낮은 응답 지연시간(latency)이 요구된다.
    - 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아니다.
    - 데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 된다.
    - 아주 많은 양의 데이터를 저장할 필요가 있다.

### **수직적 규모 확장 vs 수평적 규모 확장**

스케일 업(수직적 규모 확장 프로세스)은 서버에 고사양 자원(CPU, RAM)을 추가하는 행위를 말한다. 스케일 아웃(수평적 규모 확장 프로세스)는 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.

스케일 업은 단순함이 장점이나 심각한 단점이 존재한다.

- 한계가 존재한다. -> 한대의 서버에 cpu나 메모리를 무한대로 증설할 방법은 없다.
- 장애에 대한 방안이 없어 서버에 장애가 발생하면 완전히 중단된다.

이러한 단점때문에 대규모 어플리케이션은 수평적 규모 확장법이 적절하다.

### **로드밸런서**

로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽을 고르게 분산하는 역할을 한다.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/c7fb1d54-dea8-4527-8e43-81e2835195ef" width="600">

사용자는 로드밸런서의 공개 IP 주소로 접속한다. 보안을 위해 서버 간 통신은 private IP가 이용되는데 로드밸런서와 웹서버는 private 주소를 이용하여 통신한다. 부하 분산 집합에 또 하나의 웹 서버를 추가하면 장애 복구, 웹 계층의 가용성이 향상된다. 자세히 보면 다음과 같다.

- 서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다. ➡️ 전체가 다운되는 일 방지
- 트래픽 증가시 웹서버 계층에 서버를 추가하기만 하면 로드밸런스가 자동적으로 트래픽을 분산하기 때문에 웹 가용성이 향상된다.

### 데이터베이스 다중화

데이터베이스를 Master-Slave로 나누는데 쓰기 연산은 Master에서만 지원하고, 읽기 연산은 Slave에서만 지원한다. 대부분의 애플리케이션에서는 쓰기 작업 보다는 읽기 작업이 훨씬 많기 때문에 Slave 데이터베이스가 훨씬 많다.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/34f92c68-28e3-49dc-b6a7-80d9d96c1a35" width="600">

보통은 서버 사이에 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.

- 쓰기 연산 (write operation - insert, delete, update 등)은 master에서만 지원
- 읽기 연산 (read opreration)은 slave에서 지원
- 읽기 연산 > 쓰기 연산 인것을 이용하여 부 서버를 많이 가져와 다중화 처리

데이터베이스 다중화의 장점

- 더 나은 성능 : 모든 데이터 변경 연산은 Master 서버로만 전달되는 반면 읽기 연산은 Slave 데이터베이스 서버들로 분산된다. 병렬로 처리될 수 있는 쿼리의 수가 늘어나므로 성능이 좋아진다.
- 안전성: 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존될 것이다. 데이터를 지역적으로 떨어진 여러 장소에 다중화 시켜놓을 수 있기 때문이다.
- 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.

## **캐시**

캐시는 여러 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리 될 수 있도록 하는 저장소이다.

어플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 좌우되는데, 캐시는 이를 완화시켜 줌

### **캐시 계층**

- 별도의 캐시 계층을 두면 성능개선, 데이터 부하를 줄일 수 있음
- 캐시 계층의 규모를 독립적으로 확장 가능

캐시 사용시 유의할 점

- 어떤 데이터를 캐시에 저장해야 하는가?
    - 데이터 갱신(write)은 자주 일어나지 않지만, 참조(read)는 빈번하게 일어나는 데이터
- 캐시 만료 정책
    - 만료기한이 짧으면 DB호출이 잦음
    - 만료기한이 길면 원본과 차이날 가능성이 커짐
- 일관성 문제 (DB의 원본 데이터와 캐시의 사본 데이터가 일치해야함)
    - 원본을 갱신하는 연산과 캐시를 갱신하는 연산은 단일 트랜잭션으로 처리되어야 함
- SPOF를 피하기 위해 캐시서버 분산 필요
- 데이터 방출 정책 (캐시 메모리가 가득찰 경우)
    - LRU (Least Recently Used) - 마지막으로 사용된 지점이 가장 오래된 데이터를 방출
    - LFU (Least Frequently Used) - 사용빈도가 가장 적은것을 방출

## **콘텐츠 전송 네트워크(CDN)**

CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크로 정적 파일들을 캐시 즉 지리적으로 가까운 위치에 CDN서버를 두어 로딩 시간을 개선한다.

<img src="https://github.com/taeyun1215/BookReview/assets/65766105/1507be61-b9c8-4cd6-9723-da4252ad4764" width="600">

1. 어떤 사용자가 웹사이트 방문
2. 가장 가까운 CDN 서버가 정적 콘텐츠 전달

CDN 사용시 고려 사항

- 비용 : 해당 지역 제3 사업자에 의해 운영, 캐싱 안할 것을 미리 제외
- 적절한 만료 시한 설정 : 길면 신선도 저하, 짧으면 효율 저장하는
- CDN 장애 대처 방안 : CDN이 응답하지 않을 경우 원본서버에서 가져오도록 클라이언트 구성
- 콘텐츠 무효화 방법 : 오브젝트 버저닝(object versioning)

## **무상태 웹 계층**

상태 정보(사용자 세션 데이터 등)를 DB나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하여 웹 계층을 수평적으로 확장 할 수 있는 웹 계층.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/7d6db1e8-feda-4e70-b8aa-4ea7bb8a8fb9" width="600">
### **상태 정보 의존적인 아키텍처**

- 사용자 A ➡️ 서버 1 : 사용자 A의 세션 데이터
- 사용자 B ➡️ 서버 2 : 사용자 B의 세션 데이터

상태 정보 의존적인 아키텍처에서 사용자 A가 서버 2에 요청을 보내면 인증이 실패된다.

이를 해결하기 위해 로드밸런서에서 A를 1로 B를 2로하는 고정 세션이 지원하나 로드밸런서에 부담

### **무상태 아키텍처**

어떠한 웹서버로 전달해도 사용자의 상태정보를 공유 저장소에서 가져올 수 있기 때문에 단순하고 안정적이다.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/8f6dc8cb-528a-4af5-a491-4972a589b5fe" width="600">
### 데이터 센터

전세계 사용자를 대상으로 커질 경우 여러 데이터 센터 필요해진다. 사용자는 가까운 데이터 센터로 안내되는 것을 **지리적 라우팅**이라고 부른다.
<img src="https://github.com/taeyun1215/BookReview/assets/65766105/dd62876e-fd56-4c54-84f6-12847cba2948" width="600">
- 지리적 라우팅(geo DNS) : 사용자의 위치에 따라 도메인 이름을 가장 가까운 IP주소로 변환
- 데이터 동기화 : 데이터센터에 걸쳐 데이터를 다중화

다음과 같은 기술적 난제를 해결해야 한다.

- 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내야함, GeoDNS가 해결
- 데이터 동기화 : 데이터 센터마다 다른 데이터 베이스를 사용할 경우 찾는 데이터가 없을 수도 있다.데이터를 여러 데이터센터에 걸처 다중화 하는 것으로 해결
- 테스트와 배포 : 여러 위치에서 테스트하는 것이 중요, 자동화된 배포도구를 통해 모든 데이터 센터에 동일한 서비스가 설치 되도록해야한다.

### 메세지 큐

무손실을 보장하고 비동기 통신을 지원하는 컴포넌트 

<img src="https://github.com/taeyun1215/BookReview/assets/65766105/7b7bb45d-6bb5-49e8-bbb8-a38b33ca96a8" width="600">

- 발행자(Publisher) : 메세지 발행(Publish)
- 구독자(Subscriber) : 메세지에 맞는 동작 수행

**특징**

- 서버간 결합이 느슨해져, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋음.
- 소비자 프로세스가 다운되어 있어도 메시지 발행이 가능하며, 생산자 서비스가 가용상태가 아니더라도 메시지 수신 가능.

### 로그, 메트릭 그리고 자동화

- 로그 : 에러 로그를 단일 서비스로 모아주는 도구 활용
- 메트릭 : 시스템 상태 정보
    - 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O에 관한 메트릭
    - 종합 메트릭 : 데이터베이스, 캐시 계층의 성능
    - 핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문
- 자동화 : 시스템이 크고 복잡해지면 자동화 도구를 활용해야 함

### **수직적 확장**

이 접근법은 기존 서버의 자원(CPU, RAM, 디스크 등)을 증가시키는 방식으로, 고성능의 하드웨어 추가를 통해 처리 능력을 향상시킨다.

**단점:**

- **하드웨어 한계:** 물리적 자원에는 한계가 있으며, 이로 인해 확장에는 한계가 있다.
- **단일 실패 지점(SPOF) 위험:** 모든 데이터와 처리 능력이 단일 서버에 집중되어 있어, 이 서버에 문제가 발생하면 전체 시스템이 영향을 받을 수 있다.
- **비용:** 고성능 하드웨어의 추가는 비용이 많이 들 수 있으며, 특히 규모가 커질수록 그 비용은 기하급수적으로 증가할 수 있다.

### **수평적 확장 (샤딩)**

수평적 확장, 또는 샤딩은 여러 서버에 데이터를 분산시켜 전체 시스템의 성능을 향상시키는 기술이다. 이 방식에서는 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하며, 각 샤드는 동일한 스키마를 유지하면서도 중복되지 않는 데이터를 저장한다.

**주요 고려사항:**

- **샤딩 키 선택:** 데이터를 고르게 분할하고 균등하게 분산시키는 효과적인 샤딩 키의 선택이 중요하다.
- **데이터의 재샤딩:** 샤드 소진 현상에 대응하기 위해, 샤드 간 데이터 분포를 재조정하고 샤딩 키 계산 함수를 업데이트해야 할 수 있다. 안정 해시 기법 등을 활용하여 이 문제를 해결할 수 있다.
- **유명인사 문제:** 특정 샤드에 대한 질의가 과도하게 집중되어 서버 과부하를 일으키는 문제다. 이를 해결하기 위해 유명인사 데이터를 별도로 관리하거나 더 세분화된 샤딩 전략을 고려해야 할 수 있다.
- **조인과 비정규화 문제:** 여러 샤드에 걸쳐 있는 데이터를 조인하는 것이 어려워질 수 있다. 이를 해결하기 위해 데이터베이스를 비정규화하여, 하나의 샤드 내에서 질의가 가능하도록 데이터를 조정할 수 있다.

## 사용자 수에 따른 규모 확장성





