## 근접성 서비스

### **기능 요구사항**

1. 사용자 위치 기반 검색: 사용자는 자신의 위치를 기준으로 주변의 사업장을 검색할 수 있어야 하며, 선택 가능한 검색 반경은 0.5km부터 20km까지 다양하다.
2. 사업장 정보 관리: 사업장 소유주는 자신의 사업장 정보를 추가, 수정, 삭제할 수 있으며, 이 변경사항은 검색 결과에 바로 반영될 필요는 없다.

### **비기능 요구사항**

1. 낮은 응답 지연(Latency): 검색 요청에 대한 빠른 응답이 필수적이다.
2. 데이터 보호(Data Privacy): 위치 데이터는 매우 민감한 정보이므로 보호가 중요하다.
3. 고가용성 및 확장성(Scalability): 시스템은 높은 트래픽을 처리할 수 있어야 하며, 사용량이 급증하는 시간대나 지역에서도 안정적으로 서비스를 제공할 수 있어야 한다.

### **데이터 모델 및 저장 방식**

- 읽기/쓰기 연산 비율: 읽기 연산이 쓰기 연산보다 빈번하므로, 읽기 성능을 최적화하는 것이 중요하다. 이를 위해 MySQL과 같은 관계형 데이터베이스 사용이 적합하며, 샤딩과 복제를 통해 데이터베이스의 규모 확장성과 고가용성을 확보할 수 있다.
- 지리적 데이터 저장 방식: 지오해시, 쿼드트리, 구글의 S2와 같은 다양한 알고리즘을 통해 지리적 위치 데이터를 효과적으로 저장하고 검색할 수 있다. 각각의 기술은 특정 장단점을 가지고 있어, 서비스의 요구사항에 따라 적합한 기술을 선택하는 것이 중요하다.
- 위치 데이터를 저장시:
    1. 위치별로 사업장 목록을 저장하기: 이 방법은 비슷한 위치에 있는 사업장들을 하나의 리스트로 묶어 저장한다. 이 경우, 데이터베이스의 각 행은 특정 위치와 그 위치에 속하는 사업장 ID의 리스트를 포함합니다. 이 구조는 간단한 검색에 유리하지만, 사업장 정보를 추가하거나 삭제할 때 복잡도가 증가하며, 데이터 락킹(locking)이 필요할 수 있다.
        
        
        | location | businessIds |
        | --- | --- |
        | (위치 1) | [1, 2, 3, …] |
    2. 사업장별로 위치를 저장하기: 각 사업장 ID와 연관된 위치 정보를 저장하는 방식다. 이 방법은 각 사업장별로 독립적인 위치 정보를 가지므로, 사업장의 추가나 삭제가 다른 사업장에 영향을 미치지 않고, 데이터 관리가 더 단순화됩니다. 이 구조는 사업장을 추가하거나 변경할 때 간편하며, 고유한 businessId로 인덱싱하면 중복을 방지하고 검색 성능을 높일 수 있다.
        
        
        | businessId | location |
        | --- | --- |
        | 1 | (위치 1) |
        | 2 | (위치 1) |
        | 3 | (위치 1) |
    - 책에서는 두 번째 방법을 권장한다. 첫 번째 방법은 데이터를 관리하는 애플리케이션 로직이 복잡해지고, 여러 데이터 간 충돌을 방지하기 위해 락을 사용해야 하는 경우가 많기 때문이다. 두 번째 방법은 데이터베이스의 효율성을 높이고, 각각의 사업장 정보를 더 빠르고 정확하게 관리할 수 있는 이점을 제공한다.

### **알고리즘 및 기술**

1. 지오해시(Geohash) 
    - 위치 데이터를 격자로 나누고 각 격자를 고유의 해시값으로 변환하여 저장한다. 이 방식은 검색 속도를 향상시키지만, 격자의 경계에 위치한 데이터 처리가 복잡할 수 있다.
    - 아래 그림처럼 재귀적으로 지구를 더 작은 격자로 나누면서 원하는 값까지 찾아간다.
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/3fea292a-b03d-4fe2-a330-794fb73adfbb)
    - 격자 가장자리 관련 이슈
        - 지오해시의 한 가지 문제는 격자의 경계에서 발생할 수 있다. 격자 경계에 위치한 두 점이 서로 아주 가깝더라도, 서로 다른 지오해시 값을 가질 수 있다. 이는 두 점이 지리적으로 인접해 있음에도 불구하고, 해시 알고리즘 상에서는 다른 격자에 위치하게 되어 공통의 접두어(prefix)를 공유하지 않는 경우 때문이다.
        - 예를 들어, 프랑스 라 호슈 샬레(u000)와 포메홀(ezzz) 지역은 지리적으로는 가까운 거리에 위치하지만, 각각 다른 지오해시 값을 가지고 있어 이러한 문제가 발생한다.
        - 이 문제를 해결하기 위한 일반적인 방법은 현재의 격자뿐만 아니라 주변의 모든 격자에서도 사업장 정보를 검색하는 것이다. 이는 특정 지오해시 주변의 다른 지오해시를 신속하게 찾아내는 상수 시간 연산을 통해 이루어진다.
    - 충분한 사업장 정보가 없을 경우의 해결 방안
        - 지오해시를 사용할 때, 검색된 격자와 그 주변 격자에서도 충분한 사업장 정보를 찾지 못할 수 있다. 이 경우, 다음과 같은 두 가지 해결 방안이 있다.
            1. 검색 반경 유지: 주어진 반경 내에서만 사업장 정보를 반환하며, 이는 구현이 간단하지만 사용자의 요구를 충족시키지 못할 수 있다.
            2. 검색 반경 확장: 지오해시의 마지막 비트를 삭제하여 새로운 지오해시 값을 얻고, 이를 사용해 주변 사업장을 다시 검색한다. 충분한 수의 사업장을 찾을 때까지 이 과정을 반복하며, 필요에 따라 검색 범위를 점차 확장한다.
                ![image](https://github.com/taeyun1215/BookReview/assets/65766105/676f13f6-f08f-4194-aef0-8c85371651db)
2. 쿼드트리(Quadtree)
    - 사업장 데이터를 효과적으로 관리하기 위한 자료 구조로, 2차원 공간을 재귀적으로 사분면으로 분할한다. 이 구조는 특히 각 노드의 사업장 수가 사전에 정의된 최대값(예를 들어 100개)을 넘지 않도록 설계된다. 쿼드트리의 주요 목적은 공간 검색 효율성을 극대화하여, 주어진 지역 내 사업장들을 빠르게 조회할 수 있도록 하는 것이다.
    - 아래 그림처럼 세계를 쿼드트리를 이용하여 분할하는 과정을 보여준 그림이다.
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/8a4a99a0-a633-4e18-98b4-5894333b93ab)
        - 여기는 2번밖에 안 쪼개었지만, 각 노드의 사업장 수가 최대 100개라면 100이하가 될 때까지 쪼개주어야한다.
        - 아래 그림처럼 100개 이하가 될 때까지 쪼개주면 되는 것이다.
            ![image](https://github.com/taeyun1215/BookReview/assets/65766105/e311c3e7-2a38-436d-b09e-dad86801f9a0)
        - 이 과정을 재귀적 코드로 나타내면 다음과 같다.
            
            ```java
            public void buildQuadtree (TreeNode node) {
            	if (countNumber0fBusinessesInCurrentGrid(node) > 100) {
            	node.subdivide();
            	for (TreeNode child : node.getChildren ()) {
            		buildQuadtree(child);
            	}
              }
            }
            ```
            
    - 쿼드트리는 메모리 내에 저장되며, 서버가 시작될 때 생성된다. 각 노드는 최대 사업장 수를 기준으로 하여 필요에 따라 더 작은 사분면으로 분할될 수 있다. 이러한 동적 분할 능력은 쿼드트리가 특정 지역에서 사업장의 밀도에 따라 자동으로 크기를 조정할 수 있게 해 준다.
    - 서버 운영 측면에서 쿼드트리는 초기 구축 시 상당한 시간과 자원을 요구할 수 있으며, 대규모 데이터 업데이트가 필요할 때 서버의 응답 시간이 길어질 수 있다. 따라서 쿼드트리를 사용하는 시스템은 새로운 버전을 배포할 때 서버에 부하를 최소화하는 전략을 필요로 한다. 예를 들어, 블루/그린 무중단 배포 방식을 사용하여 서비스 중단 없이 신규 버전을 적용할 수 있다.
    - 데이터 유지 관리 측면에서는, 사업장이 추가되거나 삭제될 때 쿼드트리 구조 내에서 이를 반영하기 위한 업데이트가 필요하다. 이 과정에서 다수의 노드 갱신이 동시에 발생할 수 있으며, 일관성을 유지하면서 데이터를 최신 상태로 관리하기 위해 복잡한 락(lock) 메커니즘을 사용할 수 있다. 또한, 실시간으로 데이터를 갱신하는 것이 가능하지만 설계와 구현이 복잡해질 수 있다.
3. Google S2
    - 구글이 개발한 이 기술은 공간을 채우는 힐베르트 곡선을 사용하여 위치 기반 서비스를 설계하고 구현할 때 고려해야 할 주요 요소들과 접근 방식을 소개하며, 이를 실제 비즈니스 환경에 어떻게 통합할 수 있는지를 다룬다. 이 포스팅은 데이터 모델 설계, 주요 알고리즘 선택, 그리고 시스템의 성능과 확장성을 보장하는 기술적 전략을 중심으로 구성된다.\

### **Geohash vs Quadtree**

| 특성 | 지오해시 | 쿼드트리 |
| --- | --- | --- |
| 구조 | 2차원 지리 좌표를 1차원 문자열로 인코딩한다. | 2차원 공간을 재귀적으로 네 개의 사분면으로 나눈다. |
| 정밀도 | 해시의 길이에 따라 결정된다. | 내용에 따라 동적으로 조정 가능하다. |
| 효율성 | 균일한 사업장 분포 지역에서 효율적이다. | 밀집 지역이나 변동성이 큰 지역에서 매우 효율적이다. |
| 복잡성 | 구현이 간단하지만 경계 근처에서 정확도가 떨어질 수 있다. | 구현이 더 복잡하며, 트리 구조를 위한 메모리가 필요하다. |
| 확장성 | 큰 데이터셋에 대해 추가적인 오버헤드 없이 잘 확장된다. | 노드 수가 증가함에 따라 상당한 메모리와 계산력이 필요할 수 있다. |
| 경계 문제 | 해시 경계 근처에서 인접성을 잘못 표현할 수 있다. | 경계와 분할을 정밀하게 제어할 수 있어 경계 문제를 줄일 수 있다. |
| 검색 속도 | 넓은 범위의 검색에는 빠르나, 다른 해시 영역에 있는 인접 지역을 놓칠 수 있다. | 광범위한 검색에는 느리지만, 밀집된 지역의 지역화된 검색에는 빠르다. |
| 업데이트 | 새로운 데이터를 추가하거나 변경할 때 전체 구조에 영향을 미치지 않아 업데이트가 쉽다. | 업데이트 시 트리의 일부 또는 전체를 재구축해야 하며, 자원 소모가 클 수 있다. |

### 시스템 설계

- 시스템 설계 아키텍처
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/d5bd6dcc-5a4c-4753-ae3f-e69525bb20e8)
- 로드밸런서 사용 : 빨간색 네모칸
    - 고가용성을 보장하기 위해 트래픽을 균등하게 분산시키고, 서비스 중단 없이 확장성을 제공한다.
- 데이터베이스 규모 확장 : 파란색 네모칸
    - 샤딩과 복제를 통해 데이터베이스의 읽기 및 쓰기 성능을 최적화하며, 대용량 트래픽에 대응한다.
