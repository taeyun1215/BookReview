# 내 코드가 그렇게 이상한가요?

### 1. 잘못된 구조의 문제 깨닫기

- 의미를 알수 없는 네이밍은 지향하자
    - 클래스, 메소드 등에 번호를 붙히지 않고 어떤 작업을 하는지 기술 중심에 명명법으로 사용하자
- 이해하기 어럽게 많든 조건문은 지향하자
    - 예를들어 if문이 하나의 비즈니스 로직에 적게는 5개 많게는 수십개가 들어간 코드를 만들지 말자
- 데이터 클래스
    - 데이터 밖에 없는 클래스는 다른 클래스에 의해 핸들링 된다.
    - 하지만 다른 클래스 1개가 아닌 여러 클래스에 핸들링 된다.
    - 이러한 상황은 데이터를 담고 있는 클래스와 데이터를 사용해서 계산하는 클래스가 떨어져 있을 경우를 응집도가 낮은 구조라고 한다.
    - 아래는 응집도가 낮으면 생기는 문제점들을 나열했다.
        1. 코드 중복 : 데이터 클래스를 의존하는 여러 클래스 모두 중복된 코드를 갖게 됨.
        2. 수정 누락 : 비즈니스 로직이 변경 된다면 여러 클래스들은 모두 코드 수정이 불가피 할 것이다. 코드가 많아지면 놓치는 부분이 존재할 수도 있을 것이다.
        3. 잘못된 값 할당 : 데이터 클래스에 유효성 검사가 따로 없기에 모든 유효성 검사는 데이터 클래스를 의존하는 여러 클래스는 모두 유효성 검사를 해줘야한다.
- 응집도와 결합도
    - 응집도
        - 멍청한 이야기지만…나는 여태 응집도랑 결합도가 거의 유사한 개념이라고 생각했었다.
        - 응집도는 하나의 모듈 또는 클래스 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타낸다.
        - 높은 응집도는 클래스나 모듈의 모든 메서드와 속성이 단일 목적 또는 기능에 집중되어 있다는 것을 의미한다.
        - 예를 들어, **`OrderService`** 클래스가 **`Order`** 클래스의 내부 필드에 직접 접근하고 있다. 두 클래스 사이의 결합도는 높다고 볼 수 있다.
            
            ```java
            public class Order {
                public double price;
                public int quantity;
            
                public double getTotalPrice() {
                    return price * quantity;
                }
            }
            
            public class OrderService {
                public void printOrderTotalPrice(Order order) {
                    // 직접 Order 클래스의 내부 구조에 접근
                    System.out.println(order.price * order.quantity);
                }
            }
            ```
            
    - 결합도
        - 결합도는 두 모듈 또는 클래스가 서로 얼마나 강하게 연결되어 있는지를 나타낸다.
        - 낮은 결합도는 각 클래스나 모듈이 독립적이며, 다른 클래스나 모듈의 내부 구현에 대한 지식 없이도 변경이나 확장이 가능하다는 것을 의미한다.
        - 예를 들어, **`OrderService`** 클래스가 **`Order`** 클래스의 메서드만 호출하고, **`Order`** 클래스의 내부 구조나 로직에 의존하지 않는다면, 두 클래스 사이의 결합도는 낮다고 볼 수 있다.
            
            ```java
            public class Order {
                private double price;
                private int quantity;
            
                public double getTotalPrice() {
                    return price * quantity;
                }
            }
            
            public class OrderService {
                public void printOrderTotalPrice(Order order) {
                    // Order 클래스의 제공하는 메서드만 사용
                    System.out.println(order.getTotalPrice());
                }
            }
            ```
            
    - 응집도가 높고 결합도가 낮은 설계의 장점
        - 유지 보수성 : 각 컴포넌트나 모듈이 독립적이므로, 한 부분을 수정하거나 확장해도 다른 부분에 미치는 영향이 최소화된다.
        - 재사용성: 응집도가 높은 컴포넌트나 모듈은 특정 기능에 집중하기 때문에 다른 프로젝트나 문맥에서도 재사용하기 쉽다.
        - 확장성: 결합도가 낮은 설계는 새로운 기능이나 요구 사항을 추가할 때 유연성을 가진다.
    
    ### 2. 설계 첫 걸음
    
    - 의도를 분명히 전달할 수 있는 이름 설계하기
    - 변수를 계속해서 재할당 하는것이 아닌 목적별로 변수를 따로 생성하기
        - 가독성 저하: 변수의 값이 여러 번 바뀌면 코드를 읽는 사람이 그 변수의 현재 값이 무엇인지 추적하기 어려워진다.
        - **불변성 손실**: 불변성(Immutability)은 데이터의 안정성을 보장하고 함수형 프로그래밍 패러다임에서 중요하게 여겨진다. 재할당을 많이 사용하면 불변성을 유지하기 어려워진다.
        - **리팩토링 어려움**: 변수가 재할당되는 코드는 리팩토링이나 코드의 수정이 필요할 때 변경의 범위를 예측하기 어려워진다.
    - 데이터와 로직이 묶여 있는 좋은 클래스
        
        ```java
        class OrderItem {
            private String productName;
            private double price;
            private int quantity;
        
            public OrderItem(String productName, double price, int quantity) {
                if (price < 0) {
                    throw new IllegalArgumentException("Price cannot be negative");
                }
                if (quantity < 0) {
                    throw new IllegalArgumentException("Quantity cannot be negative");
                }
        
                this.productName = productName;
                this.price = price;
                this.quantity = quantity;
            }
        
            // 해당 품목의 총 가격을 계산
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        }
        ```
        
        - 생성자를 통해 유효성 검사를 완료하였다.
        - `calculateTotalPriceForItem` → 메소드 명만 확인해도 해당 품목의 총 가격을 계산하는 로직인 걸 알수 있다.

### 3. 클래스 설계 : 모든 것과 연결되는 설계 기반

- 잘 만들어진 클래스는 두가지로 구성 되어야한다.
    1. 인스턴스 변수
        - 객체가 생성될 때마다 독립적인 메모리 공간을 갖게 되는 변수이다.
        - Java에서는 접근 제한자로 `Private`, `Public`, `Protected`로 사용되며 일반적으로 캡슐화 원칙에 따라 **`private`**로 설정되어 외부로부터 직접 접근이 제한된다.
    2. 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메소드
        - 이는 캡슐화 원칙의 일환이다. 캡슐화는 객체의 상태를 외부에서 직접 변경하지 못하게 하고, 대신 정해진 메서드를 통해서만 상태를 변경하도록 제한하는 원칙이다.
        - 예를 들어, 인스턴스 변수가 `private`로 선언되었다면, 해당 변수를 직접 조작할 수 없다. 대신, 이 변수의 값을 조회하거나 변경하기 메서드를 사용한다.
- 모든 클래스가 갖추어야 하는 자기 방어 임무
    - 다른 클래스를 사용해서 초기화와 유효성 검사를 해야 하는 클래스는 그 자체로는 안전하게 사용할 수 없는 미성숙한 클래스이다.
    - 클래스는 스스로 자기 방어 임무(혼자서 초기화와 유효성 검사 가능해야 함)를 수행할 수 있어야 소프트웨어의 품질을 높이는 데 도움이 된다.
- 성숙한 클래스로 성장시키는 설계 기법
    - 잘못된 값을 들어간 인스턴스가 생성되지 못하게 생성자를 통해 유효성을 검사한다.
        
        ```java
        class OrderItem {
            private String productName;
            private double price;
            private int quantity;
        
            public OrderItem(String productName, double price, int quantity) {
                if (price < 0) {
                    throw new IllegalArgumentException("Price cannot be negative");
                }
                if (quantity < 0) {
                    throw new IllegalArgumentException("Quantity cannot be negative");
                }
        
                this.productName = productName;
                this.price = price;
                this.quantity = quantity;
            }
        }
        ```
        
    - 불변 변수로 만들어 예상하지 못한 동작 막기
        
        ```java
        class OrderItem {
            private final String productName;
            private final double price;
            private final int quantity;
        
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        }
        ```
        
        - 이렇게 되면 생성자를 통해서만 생성이 가능하다.
    - 값을 변경하고 싶다면 새로운 인스턴스 만들기
        
        ```java
        class OrderItem {
            private final String productName;
            private final double price;
            private final int quantity;
        
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        
            public OrderItem updatedQuantity(int newQuantity) {
                return new OrderItem(productName, price, newQuantity);
            }
        }
        ```
        
        - 이렇게 하면 불변을 유지하면서도 값을 변경할 수 있다.
- 위와 마찬가지로 메소드의 매개변수, 지역 변수도 불변으로 만들수 있다.
- 값 객체
    - 값 객체란 값을 클래스(자료형)로 나타내는 디자인 패턴이다.
    - 금액, 날짜 등을 사용하게 되면 각각의 값과 로직이 있기에 응집도가 높은 구조로 만들 수 있다.
    - 예를 들어 금액을 단순한 int형으로 두었다면 상품의 개수 가격등에 사용이 되며 실수로 의미가 다른 값이 섞을수도 있다.
    - 값 객체 + 완전 생성자는 객체 지향 설계에서 많이 사용되는 기법이다.
### 4. 불변 활용하기 : 안정적으로 동작하게 만들기

- 재할당
    - 변수에 값을 다시 할당하는 것을 재할당이라하며 재할당은 변수의 의미를 바꿔 추측하기 어렵고 언제 어떻게 변경되었는지 추척하기가 어렵다.
- 재할당을 방지하기 위해 불변 변수로 만들기
    - 지역변수는 물론 메소드의 매개변수도 불변 변수로 변경한다.
- 가변으로 인해 발생하는 의도하지 않은 영향
    
    ```java
    class OrderItem {
        private String productName;
        private double price;
        private int quantity;
    }
    
    class Order {
        final OrderItem orderItem;
    
        Order(OrderItem orderItem) {
            this.orderItem = orderItem;
        }
    }
    
    public class OrderServiceDemo {
        public static void main(String[] args) {
            OrderItem sharedOrderItem = new OrderItem("Laptop", 1000, 1);
    
            Order order1 = new Order(sharedOrderItem);
            Order order2 = new Order(sharedOrderItem);
    
            // order1의 가격 변경
            order1.orderItem.price(1200);
    
            System.out.println("Order1 Total Price after: " + order1.OrderItem.price);
            System.out.println("Order2 Total Price after: " + order2.OrderItem.price);
        }
    }
    ```
    
    - 지금 보면 order1의 가격만 변경을 하였는데, 출력을 하게 되면 order1, order2 두 객체 모두 가격이 1200으로 변경되었다.
    - 이처럼 가변 인스턴스 변수는 예상하지 못한 동작을 일으킨다.
- 부수 효과의 단점
    - 함수의 부수 효과는 '함수가 매개변수를 전달받고, 값을 리턴하는 것' 이외에 외부 상태(인스턴스 변수 등)을 변경하는 것을 가르킨다.
    - 상태 변경이란 함수 밖에 있는 상태를 변경하는 것을 의미한다.
        - 인스턴스 변수 변경
        - 전역 변수 변경
        - 매개변수 변경
        - 파일 읽고 쓰기 같은 I/O 조작
- 함수의 영향 범위 한정하기
    - 함수는 아래 항목을 만족하도록 설계하는 것이 좋다.
        - 상태는 매개변수로 받는다.
        - 상태를 변경하지 않는다.
        - 같은 함수의 리턴 값으로 돌려준다.
    - 잘못된 예시
        
        ```java
        public class OrderItem {
            private double price;
            private int quantity;
            private static double discount = 0.1;  // 전역적인 할인율
        
            public void calculateDiscountedPrice() {  // 상태를 매개변수로 안 받는다.
                this.price * (1 - discount);  // 상태를 변경한다.
            }
        }
        ```
        
    - 올바른 예시
        
        ```java
        public class OrderItem {
            private final double price;  // 불변성을 위해 final 키워드 사용한다.
            private final int quantity;  // 불변성을 위해 final 키워드 사용한다.
        
            public OrderItem(double price, int quantity) {
                this.price = price;
                this.quantity = quantity;
            }
        
            public double calculateDiscountedPrice(double discount) {  // 상태는 매개변수로 받는다.
                return price * (1 - discount);  // 상태를 변경하지 않고, 같은 입력에 대해 항상 같은 값을 반환한다.
            }
        }
        ```
        
        - calculateDiscountedPrice에 새로운 객체를 반환하지 않았던 이유는 기존 객체의 상태를 변경하거나 새로운 OrderItem 객체를 생성하는 것이 아니라, 단순히 계산된 값만 반환하기 위함이다.
        - 메소드의 목적에 따라 다를수 있지만 해당 메소드는 객체의 상태를 변경하는 것이 아니라 특정 값만 계산하여 반환하는거라 새로운 객체를 반환하여 불변성을 유지시킬 이유가 없다. 라고 생각했다.
        - 만약 상품의 개수(quantity)를 변경하는 거라면 새로운 객체를 생성해서 불변상태를 유지 시켜주는 것이 좋을 것이다.
            
            ```java
            public OrderItem updateQuantity(final int newQuantity) {
                return new OrderItem(this.price, newQuantity);
            }
            ```
            
- 기본적으로는 불변으로
    - 장점
        - 변수의 의미가 변하지 않으므로, 혼란을 줄일 수 있음
        - 동작이 안정적이게 되므로, 결과를 예측하기 쉬움
        - 코드의 영향 범위가 한정적이므로, 유지 보수가 편리해짐
- 가변으로 설계해야 하는 경우
    - 대량의 데이터를 빠르게 처리해야하는 경우
    - 이미지를 처리하는 경우
    - 위와 같이 가변으로 설계해야하는 이유는?
        - 불변이라면 값을 변경할 때 인스턴스를 새로 생성해야한다.
        - 만약 크기가 큰 인스턴스를 새로 생성하면서 시간이 오래 걸려 성능에 문제가 있다면, 불변보단 가변을 사용해야한다.
- 상태를 변경하는 메서드 설계하기
    - 상태를 변화시키는 메소드를 뮤테이터(Mutater)라고 부른다.
    - 뮤테이터의 예시는 아래와 같다.
        
        ```java
        public class OrderItem {
            private final double price;
            private int quantity;
        
            // 수량 변경 메서드 (가변성 도입)
            public void updateQuantity(int newQuantity) {
                this.quantity = newQuantity;
            }
        }
        ```
        
        - 웹 개발자라면 한번쯤 이렇게 코드를 짜보지 않을까 한다.
        - 해당 도메인 엔티디에 대해 값 변경을 메소드를 통해 이뤄지고, Repo를 통해 저장을 할 것이다.
        - 이런 경우도 있다라는 예시로 들어보았다.

### 5. **응집도 : 흩어져 있는 것들**

- static 메소드 오용
    - static 메소드는 전역적으로 사용이 가능하다. → 클래스 인스턴스를 생성하지 않는다.
    - static 메소드의 구조적 문제
        - 데이터와 비즈니스 로직이 분리되어 있어서 응집도가 낮다.
    - static 메소드를 사용한 예시
        
        ```java
        public class Order {
            private List<OrderItem> orderItems;
        
            // 응집도가 낮은 static 메소드
            public static double calculateVAT(double price) {
                return price * 0.1;  // 부가세 10% 계산
            }
        }
        
        // 인스턴스를 생성하지 않고 호출
        double vatAmount = Order.calculateVAT(totalPrice);
        ```
        
- 인스턴스 메서드인 척 하는 static 메소드 주의하기
    
    ```java
    public class Order {
        private List<OrderItem> orderItems;
    
        // 인스턴스 메소드인 척 하는 static 메소드
        public double calculateDiscountedPrice(double originalPrice, double discountRate) {
            return originalPrice * (1 - discountRate);
        }
    }
    ```
    
    - `calculateDiscountedPrice` → orderItems을 전혀 사용하지 않는 메소드이다.
    - 이렇게 되면 앞에서 예시로 보여줬던 `calculateVAT`와 거의 동일하다.
- static 메소드를 왜 사용할까?
    - static 메소드는 절차 지향 언어의 접근 방법에서 사용한다.
    - 절차 지향 언어에서는 데이터와 비즈니스 로직이 별개로 존재하도록 설계한다.
    - 따라서 클래스의 인스턴스를 생성하지 않고도 사용할 수 있는 static 메소드를 사용한다.
    - static 메소드는 클래스의 인승턴스를 만들지 않아도 되기에 간단하게 사용이 가능하지만, 응집도가 낮아지는 문제가 있다. 적재적소에 사용하는 것이 중요하다.
- 어떤 상황에서 static 메소드를 사용해야 좋을까?
    - 로그 출력 전용 메소드, 포맷 변환 전용 메소드 등에서 쓰인다.
    - 해당 메소드들은 응집도와 관계가 없기에 static으로 사용하는게 좋다.
- 매개변수가 너무 많은 경우
    - 매개변수가 많아지면 응집도가 낮아질 수 있다.
    - 그 이유는 아래와 같다.
        - 해당 메소드에서 너무 많은 일을 하려고 할 수 있기에 이는 저 응집도의 신호이다. 즉, 하나의 메소드가 여러 가지 책임을 지니고 있을 가능성이 높다.
- 기본 자료형에 대한 집착
    - 기본 자료형에 대한 집착을 하게 되는 경우 데이터와 비즈니스 로직이 분산된다.
    - 그렇게 되면 중복된 코드가 많이 생기므로 응집도가 낮아진다.
    - 잘못된 예시 → 기본 자료형만 사용한 코드
        
        ```java
        public class OrderService {
            
            public double applyDiscount(double orderAmount, double discountRate) {
                if (orderAmount < 0) {
                    throw new IllegalArgumentException("Amount cannot be negative");
                }
                if (discountRate < 0) {
                    throw new IllegalArgumentException("discountRate cannot be negative");
                }
                return orderAmount * (1 - discountRate);
            }
        
            public double calculateVAT(double orderAmount) {
                if (orderAmount < 0) {
                    throw new IllegalArgumentException("Amount cannot be negative");
                }
                return orderAmount * 0.1;  // 10% VAT
            }
        }
        ```
        
        - 매개변수 orderAmount의 유효성 검사를 중복되게 하는 것을 볼 수 있다.
    - 올바른 예시 → 기본 자료형을 클래스로 응집한 코드
        
        ```java
        
        public class OrderAmount {
            private final double amount;
        
            public OrderAmount(double amount) {
                if (amount < 0) {
                    throw new IllegalArgumentException("Amount cannot be negative");
                }
                this.amount = amount;
            }
        }
        
        // DiscountRate 클래스
        public class DiscountRate {
            private final double rate;
        
            public DiscountRate(double rate) {
                if (rate < 0 || rate > 1) { // 0 ~ 1 사이의 값만 유효하다고 가정
                    throw new IllegalArgumentException("Discount rate must be between 0 and 1");
                }
                this.rate = rate;
            }
        
            public double applyTo(double amount) {
                return amount * (1 - rate);
            }
        }
        
        // OrderService 클래스
        public class OrderService {
            private final OrderAmount orderAmount;
            private final DiscountRate discountRate;
        
            public OrderService(OrderAmount orderAmount, DiscountRate discountRate) {
                this.orderAmount = orderAmount;
                this.discountRate = discountRate;
            }
        
            public double applyDiscount() {
                return discountRate.applyTo(orderAmount.getAmount());
            }
        
            public double calculateVAT() {
                return orderAmount.getAmount() * 0.1;
            }
        }
        ```
        
        - 이렇게 만들어진 코드는 다양한 장점이 있다.
            1. 캡슐화 : OrderAmount, DiscountRate 클래스는 자신의 상태와 관련된 유효성 검사와 동작을 자체적으로 처리한다. 이는 외부에서 이 클래스들의 내부 상태나 구현 방식을 알 필요 없이 사용할 수 있다는 것을 의미한다.
            2. 응집도 : OrderAmount는 주문 금액과 관련된 로직만, DiscountRate는 할인율과 관련된 로직만 책임지게 된다. 각 클래스는 그에 해당하는 역할만을 수행하므로 응집도가 높아진다.
            3. 재사용성 : OrderAmount나 DiscountRate와 같은 클래스는 다른 서비스나 기능에서도 사용될 가능성이 있다. 이렇게 독립적으로 잘 정의된 클래스는 다른 부분에서도 재사용하기 쉽다.
- 묻지 말고 명령하기
    - 다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, 메소드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라는 의미이다.
    - 잘못된 예시
        
        ```java
        public class Order {
            private ShippingStatus shippingStatus;
        
            public ShippingStatus getShippingStatus() {
                return shippingStatus;
            }
        
            public void setShippingStatus(ShippingStatus status) {
                this.shippingStatus = status;
            }
        }
        
        public class OrderService {
            public void shipOrder(Order order) {
        		// order 객체에게 묻고 있다.
                if (order.getShippingStatus() == ShippingStatus.PENDING) {
                    order.setShippingStatus(ShippingStatus.SHIPPED);
                }
            }
        }
        ```
        
    - 올바른 예
        
        ```java
        public class Order {
            private ShippingStatus shippingStatus;
        
            public void ship() {
                if (this.shippingStatus == ShippingStatus.PENDING) {
                    this.shippingStatus = ShippingStatus.SHIPPED;
                }
            }
        }
        
        public class OrderService {
            public void shipOrder(Order order) {
        		// order 객체에게 묻는 것이 아닌 order 객체가 주체적으로 제어한다.
                order.ship();
            }
        }
        ```
### 6. 조건 분기 **: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법**

- 조건 분기가 중첩되어 낮아지는 가독성
    - 예시
        ```java
        if (조건) {
            // 수십 ~ 수백 줄의 코드
            if (조건) {
                // 수십 ~ 수백 줄의 코드
                if (조건) {
                    // 수십 ~ 수백 줄의 코드
                    if (조건) {
                        // 수십 ~ 수백 줄의 코드
                    }
                }
            }
        }
        ```
        
        - 이처럼 코드를 짠 사람도 이해하기 어려울 정도의 중첩 분기문인데, 팀 단위로 같이 작업할 땐 얼마나 더 심하겠는가
- 조기 리턴으로 중첩 제거하기
    - 예시
        
        ```java
        public class OrderService {
        
            public String processOrder(Order order) {
                if (!order.isPaid()) return "Order has not been paid!";
                if (!order.isInStock()) return "Item is out of stock!";
                if (!order.hasValidShippingAddress()) return "Invalid shipping address!";
                
                order.ship();
        
                return "Order has been shipped!";
            }
        }
        ```
        
        - 조기 리턴으로 중첩이 제거 되어서 가독성이 좋아졌다.
    - 요구사항이 추가되었다고 가정하게 된다면, 아래와 같다.
        
        ```java
        public class OrderService {
        
            public String processOrder(Order order) {
                if (!order.isPaid()) return "Order has not been paid!";
                if (!order.isInStock()) return "Item is out of stock!";
                if (!order.hasValidShippingAddress()) return "Invalid shipping address!";
        				if (order.getItemCount() < 2) order.addShippingFee();  // 분기 요구사항
        
                order.ship();
        				order.setFreeShipping();  // 비즈니스 요구사항
        
                return "Order has been shipped!";
            }
        }
        ```
        
        - 위와 같이 매우 간단하게 요구사항을 추가할 수 있다.
- 전략 패턴(정책 패턴)
    - 전략패턴이란 여러 유사한 알고리즘을 캡슐화해서 객체의 행위를 동적으로 변경 가능하게 만드는 패턴이다.
    - OCP(개방폐쇄의 원칙) : 변경엔 닫혀있고 확장엔 열려있는 객체지향 원칙이 실현된다.
        - 다른 행동 및 전략이 추가된다고 해도 기존의 코드는 변경하지 않고 확장이 가능하다.
    - 전략 패턴을 사용하지 않은 예
        
        ```java
        public class DiscountService {
            public double applyDiscount(double orderAmount, String discountType) {
                if ("PERCENT_10".equals(discountType)) {
                    return orderAmount * 0.9;
                } else if ("PERCENT_20".equals(discountType)) {
                    return orderAmount * 0.8;
                } else if ("FLAT_50".equals(discountType)) {
                    return orderAmount - 50;
                }
                return orderAmount;
            }
        }
        ```
        
        - 이 방식의 문제점은 새로운 할인 유형이 추가될 때마다 applyDiscount 메서드를 수정해야 한다는 것이다.
        - 또한, DiscountService 클래스에만 이런 조건이 있는게 아니라 다른 클래스에도 유사한 조건이 있다면 모두 수정이 필요하다.
    - 전략 패턴을 사용 예
        
        ```java
        interface DiscountStrategy {
            double apply(double orderAmount);
        }
        
        class Percent10Discount implements DiscountStrategy {
            public double apply(final double orderAmount) {
                return orderAmount * 0.9;
            }
        }
        
        class Percent20Discount implements DiscountStrategy {
            public double apply(final double orderAmount) {
                return orderAmount * 0.8;
            }
        }
        
        class Flat50Discount implements DiscountStrategy {
            public double apply(final double orderAmount) {
                return orderAmount - 50;
            }
        }
        
        public class DiscountService {
            private DiscountStrategy strategy;
        
            public DiscountService(DiscountStrategy strategy) {
                this.strategy = strategy;
            }
        
            public double applyDiscount(double orderAmount) {
                return strategy.apply(orderAmount);
            }
        }
        ```
        
        - 이제 새로운 할인 유형이 추가되면 DiscountService 클래스를 수정할 필요 없이 새로운 DiscountStrategy 구현만 추가하면 된다.
        - 이는 코드의 확장성을 향상시키고, 변경에 대한 영향을 최소화하는 데 도움을 줍니다.
- 자료형 확인에 조건 분기 사용하지 않기
    - 자료형을 조건 분기로 사용하게 되면 모처럼 if문을 없애기 위해 전략 패턴을 사용했는데 다시금 생기는 것입니다.
    - 처음에 한번 생기는 건 괜찮아 질수도 있지만, 지름길을 찾게 된다면 점점 유지보수 하기 어려운 코드를 만들게 될 것입니다. 이러한 방식을 깨진 유리창 이론이라고 합니다.
    
    <aside>
    💡 깨진 유리창 이론이란?
    
    - 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기가 쉽다.
    - 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉽다.
    - 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.
    - 즉, 레거시 코드가 될 가능성이 높습니다.
    </aside>
    
    - 자료형 확인에 조건 분기를 사용한 안 좋은 예시
        
        ```java
        public class DiscountService {
            private DiscountStrategy strategy;
        
            public DiscountService(DiscountStrategy strategy) {
                this.strategy = strategy;
            }
        
            public double applyDiscount(double orderAmount) {
                if (strategy instanceof Flat50Discount) {
                    orderAmount += 30;
                }
                return strategy.apply(orderAmount);
            }
        }
        ```
        
        - 이렇게 되면 점점 분기문이 추가될 것이다.
    - 자료형 확인에 조건 분기를 사용하지 않은 좋은 예시
        
        ```java
        interface DiscountStrategy {
            double apply(double orderAmount);
        }
        
        class Flat50Discount implements DiscountStrategy {
            public double apply(final double orderAmount) {
                return orderAmount - 50 + 30;
            }
        }
        
        public class DiscountService {
            private DiscountStrategy strategy;
        
            public DiscountService(DiscountStrategy strategy) {
                this.strategy = strategy;
            }
        
            public double applyDiscount(double orderAmount) {
                return strategy.apply(orderAmount);
            }
        }
        ```
        
        - 이렇게 하면 분기문을 추가하지 않고 처리가 가능하다.
    - 단, DiscountStrategy의 구현체인 다른 클래스도 공통된 로직이 추가가 된다면 DiscountStrategy에 새로운 메소드를 구현해서 모든 구현체에서도 해당 비즈니스 로직을 추가해주면 될 것이다.
### 7. 컬렉션 : 중첩을 제거하는 구조화 테크닉

- 이미 존재하는 기능을 다시 구현하지 말자
    - for문과 if문이 동시에 있는 코드는 가독성이 좋지 못합니다.
    - 안 좋은 예시
        
        ```java
        public boolean hasAnyProcessingOrder(List<Order> orders) {
            for (Order order : orders) {
                if ("processing".equals(order.getStatus())) {
                    return true;
                }
            }
            return false;
        }
        ```
        
    - 좋은 예시
        
        ```java
        public boolean hasAnyProcessingOrder(List<Order> orders) {
            return orders.stream().anyMatch(order -> "processing".equals(order.getStatus()));
        }
        ```
        
        - anyMatch 메소드를 알고 있으면, 복잡한 로직을 직접 구현하는 것이 아닌 한줄로 처리가 가능하다.
- 조기 Contiune로 조건 분기 중첩 제거하기
    - for문 안에 조건 분기문이 중첩 되어 있는 경우 가독성이 좋지 못합니다.
    - 안 좋은 예시
        
        ```java
        public boolean hasSpecificOrder(List<Order> orders) {
            for (Order order : orders) {
                if ("processing".equals(order.getStatus())) {
                    if (order.getAmount() > 1000) {
                        if (order.getOrderDate().isEqual(LocalDate.now())) {
                            order.setStatus("processed");
        				            System.out.println("Order has been processed: " + order);
                        }
                    }
                }
            }
        }
        ```
        
    - 좋은 예시
        
        ```java
        public boolean hasSpecificOrder(List<Order> orders) {
            for (Order order : orders) {
                if (!"processing".equals(order.getStatus())) continue;
                if (order.getAmount() <= 1000) continue;
                if (!order.getOrderDate().isEqual(LocalDate.now())) continue;
        
                order.setStatus("processed");
                System.out.println("Order has been processed: " + order);
            }
        }
        ```
        
        - 중첩 분기문으로 들여쓰기 하는 것보다 훨씬 더 나은 코드의 형태를 볼 수 있다.
- 응집도가 낮은 컬렉션 처리하기
    - 컬렉션과 관련된 작업을 처리하는 코드는 여기저기 생길 수가 있다.
    - 안 좋은 예시
        
        ```java
        public class OrderService {
            private List<Order> orders;
        
            public boolean hasSpecificOrder() {
                return orders.stream().anyMatch(order -> 
                    "processing".equals(order.getStatus()) &&
                    order.getAmount() > 1000 &&
                    order.getOrderDate().isEqual(LocalDate.now())
                );
            }
        }
        
        public class ReportService {
            private List<Order> orders;
        
            public List<Order> getProcessingOrdersFromTodayWithHighAmount() {
                return orders.stream().filter(order -> 
                    "processing".equals(order.getStatus()) &&
                    order.getAmount() > 1000 &&
                    order.getOrderDate().isEqual(LocalDate.now())
                ).collect(Collectors.toList());
            }
        }
        ```
        
    - 좋은 예시
        
        ```java
        public class Orders {
            private List<Order> orders;
        
            public Orders(List<Order> orders) {
                this.orders = orders;
            }
        
            public boolean hasSpecificOrder() {
                return orders.stream().anyMatch(this::matchesCriteria);
            }
        
            public List<Order> getProcessingOrdersFromTodayWithHighAmount() {
                return orders.stream().filter(this::matchesCriteria).collect(Collectors.toList());
            }
        
            private boolean matchesCriteria(Order order) {
                return "processing".equals(order.getStatus()) &&
                       order.getAmount() > 1000 &&
                       order.getOrderDate().isEqual(LocalDate.now());
            }
        }
        ```
        
        ```java
        public class OrderService {
            private Orders orders;
        
            public boolean hasSpecificOrder() {
                return orders.hasSpecificOrder();
            }
        }
        
        public class ReportService {
            private Orders orders;
        
            public List<Order> getProcessingOrdersFromTodayWithHighAmount() {
                return orders.getProcessingOrdersFromTodayWithHighAmount();
            }
        }
        ```
        
        - 이렇게 되면 컬렉션과 관련된 응집도가 높아진다. → 데이터와 비즈니스 로직이 같이 있다.

### 8. 강한 결합 : 복잡하게 얽혀서 풀 수 없는 구조

- 결합이 생긴 여러 코드
    - 결합도가 높으면 안 좋은 점
        - 한 클래스의 변경이 다른 의존하는 클래스 모두 영향을 미친다.
        - 의존 받는 클래스가 변경되면 의존 하는 클래스들은 변경이 필수적이다. → 유지보수가 어려움.
        - 단일 책임 원칙을 위반한다.
    - 안 좋은 예시
        
        ```java
        public class OrderService {
            private List<Order> orders = new ArrayList<>();
            private int totalAmount = 0;
        
            public boolean addOrder(Order order) {
                if (!isValid(order)) {
                    throw new IllegalArgumentException();
                }
        
                int amountAfterDiscount = order.getPrice();
                if (order.isDiscountApplicable()) {
                    amountAfterDiscount = applyDiscount(order.getPrice());
                }
        
                if (totalAmount + amountAfterDiscount <= 10000) {
                    totalAmount += amountAfterDiscount;
                    orders.add(order);
                    return true;
                } else {
                    return false;
                }
            }
        
            private boolean isValid(Order order) {
                return order.getId() >= 0 && !order.getName().isEmpty();
            }
        
            private int applyDiscount(int price) {
                return price - 100; 
            }
        }
        
        public class SeasonalOrderService {
            private OrderService orderService = new OrderService();
        
            public boolean addSeasonalOrder(Order order) {
                if (order.getId() < 0 || order.getName().isEmpty()) {
                    throw new IllegalArgumentException();
                }
        
                int amountAfterDiscount = order.getPrice();
                if (order.isDiscountApplicable()) {
                    amountAfterDiscount = orderService.applyDiscount(order.getPrice());  // Problem here
                }
        
                if (orderService.totalAmount + amountAfterDiscount <= 12000) {  // Problem here
                    orderService.totalAmount += amountAfterDiscount;  // Problem here
                    orderService.orders.add(order);  // Problem here
                    return true;
                } else {
                    return false;
                }
            }
        }
        ```
        
        - **`SeasonalOrderService`**가 **`OrderService`**의 내부 로직과 상태를 변경하고 있습니다.
        - 이는 단일 책임 원칙을 위배하며, 두 클래스가 강하게 결합됩니다.
- 중복된 코드를 핸들링하기
    - 중복된 코드를 핸들링 하기 위해서는 아래와 같은 방법들이 있다.
        - 상속
        - 컴포지션
        - 전략패턴
    - 상속은 후에 다룰 예정이라 넘어가겠다.
    - 컴포지션과 전략패턴이 유사한 내용을 띄고 있지만 내가 생각하기엔 약간에 차이가 있는 것 같다.
    - 둘의 차이는 동일한 코드의 중복을 피하려면 컴포지션을 사용하고 Class를 이용한다. 동일한 문제를 해결하는 다양한 방법(전략)을 유연하게 교체하려면 전략 패턴을 사용하고 Interface를 사용한다.
    - 컴포지션 + 전략패턴 예시
        
        ```java
        // 전략 패턴(기본 할인 정책과 여름 할인 정책이 개념(할인 정책)은 같으나 비즈니스 로직이 다름.)
        interface DiscountPolicy {
            int MIN_AMOUNT = 0;  // 최소 할인 금액
            int applyDiscount(int price);
        }
        
        // 할인 정책 1 (기본 할인 정책)
        class FlatDiscountPolicy implements DiscountPolicy {
            private final int discountAmount;
        
            FlatDiscountPolicy(int discountAmount) {
                this.discountAmount = discountAmount;
            }
        
            @Override
            public int applyDiscount(int price) {
                return Math.max(price - discountAmount, MIN_AMOUNT);
            }
        }
        
        // 할인 정책 2 (여름 할인 정책)
        class PercentageDiscountPolicy implements DiscountPolicy {
            private final double discountPercentage;
        
            PercentageDiscountPolicy(double discountPercentage) {
                this.discountPercentage = discountPercentage;
            }
        
            @Override
            public int applyDiscount(int price) {
                return (int) Math.max(price * (1 - discountPercentage), MIN_AMOUNT);
            }
        }
        
        // OrderBasicSaleService , OrderSummerSaleService 동일 코드 분리
        class OrderProcessor {
            private final DiscountPolicy discountPolicy;
        
            OrderProcessor(DiscountPolicy discountPolicy) {
                this.discountPolicy = discountPolicy;
            }
        
            public int processOrder(Order order) {
                int amountAfterDiscount = order.getPrice();
                if (order.isDiscountApplicable()) {
                    amountAfterDiscount = discountPolicy.applyDiscount(order.getPrice());
                }
                return amountAfterDiscount;
            }
        }
        
        // 기본 할인
        class OrderBasicSaleService {
            private final OrderProcessor orderProcessor; // 컴포지션(has-a 관계)
        
            OrderBasicSaleService() {
                this.orderProcessor = new OrderProcessor(new FlatDiscountPolicy(100));
            }
        
            public boolean addOrder(Order order) {
                int finalAmount = orderProcessor.processOrder(order); // 위임(orderProcessor에게 위임함.)
                return true;
            }
        }
        
        // 여름 할인
        class OrderSummerSaleService {
            private final OrderProcessor orderProcessor; // 컴포지션(has-a 관계)
        
            OrderSummerSaleService() {
                this.orderProcessor = new OrderProcessor(new PercentageDiscountPolicy(0.1));
            }
        
            public boolean addOrder(Order order) {
                int finalAmount = orderProcessor.processOrder(order); // 위임(orderProcessor에게 위임함.)
                return true;
            }
        }
        ```
        
        - 이렇게 만들게 되면 재사용성에 유용하다. → 새로운 할인 정책이 나온다고 했을 때 `OrderProcessor`를 변경하는 것이 아닌 새로운 클래스를 만들고 생성자를 통해 생성하면 된다.
        - 단일 책임 원칙을 지킨다. → `OrderProcessor`는 할인 로직을 처리하는 책임만 가지고 있으므로 서비스 클래스들은 주문 처리 로직에만 집중하면 된다.
- DRY(Don’t Repaet Yourself) 원칙의 잘못된 적용
    - 위에서 예시로 만든 `OrderService`, `SeasonalOrderService` 두 클래스는 거의 유사한 코드를 가지고 있다.
    - 유사한 코드를 무작정 줄이고 싶은 생각이 들기도 하지만, 책무를 생각하지 않고 로직의 중복을 제거해서는 안 된다.
    - 예를 들어 `OrderService`, `SeasonalOrderService`를 컴포지션를 사용해서 묶었다고 가정 했을 때, 갑자기 `SeasonalOrderService`의 할인 정책이 바뀌게 된다면 오히려 중복을 제거하려 했다가 더 큰 공사를 하게 될 것이다.
    - **따라서 같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해줘야한다.**
- 상속과 관련된 강한 결합
    - 상속을 사용하게 되면 단점
        - 하위 클래스가 상위 클래스의 구현에 의존하게 되어, 상위 클래스의 변경이 하위 클래스에 영향을 줄 수 있다. → 강한 결합이 생김.
        - 하위 클래스가 상위 클래스의 내부 구조와 상태에 접근이 가능하다. → 캡슐화 유지 어려움.
    - 해결하기 위해서는 컴포지션, 전략 패턴, 위임으로 해결이 가능하다.
- Private 메소드가 많다는 것은 책임이 너무 많다는 것
    - private 메소드를 많이 사용하는 것보단 책임을 다른 클래스로 분리하는 것이 낫다.

### 9. 설계의 건전서을 해치는 여러 악마

- YAGNI 원칙
    - YAGNI(You Aren’t Gonna Nedd It)은 지금 필요 없는 기능을 만들지 말라 입니다.
    - 왜냐하면 소프트웨어에 대한 요구사항은 매일매일 변화한다. 사양으로 확정되지 않고 명확하게 언어화되지 않은 요구를 미리 예측하고 구현해도, 이러한 예측은 대부분 맞지 않는다.
    - 예측에 들어맞지 않는 로직은 데드 코드가 된다.
    - 또한, 가독성을 낮추고 읽는 사람을 혼란스럽게 만든다.
- null 문제
    - null로 객체를 초기화 시킨다면, 여러 군데에서 null을 체크해야하는 일이 발생한다. → 가독성이 떨어집니다.
    - 또한 실수로 null을 체크 안 하는 곳이 생길 수도 있다. → 에러 발생
    - 따라서, null을 리턴하지 않는 설계, null을 전달하지 않는 설계를 해야한다.
- null 안전
    - null 안전이란 null에 의한 오류가 아예 발생하지 않게 만드는 구조이다.
    - null 안전 예시
        
        ```java
        String name1 = "John";
        Optional<String> opt1 = Optional.ofNullable(name1); // opt1은 "John" 값을 포함하는 Optional이다.
        
        String name2 = null;
        Optional<String> opt2 = Optional.ofNullable(name2); // opt2는 값이 없는 Optional로, Optional.empty()와 같다.
        ```
        
- 예외를 Catch 하고서 무시하는 코드
    - 코드에 오류가 났는데도 오류를 탐지할 방법이 없어진다.
    - 어느 시점에서 어떤 코드에서 문제가 발생했는지 찾기가 힘들어진다.
    - 안 좋은 예시
        
        ```java
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
        
        }
        ```
        
    - 좋은 예시
        
        ```java
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            // 1. 로그 남기기
            System.err.println("An error occurred: " + e.getMessage());
        
            // 2. 사용자에게 의미 있는 메시지 표시
            System.out.println("You tried to divide by zero. Please provide a valid denominator.");
        
            // 3. 프로그램의 흐름 조정
            // 예를 들면, 다시 입력을 받는다거나 기본값을 설정할 수 있다.
        }
        ```
        
        - 문제가 생겼다면 Catch에서 통지 및 기록을 해두는것이 좋다.
- Sliver Bullet
    - Sliver Bullet이란? 울버린, 늑대인간, 드라큘라와 같은 괴물들에게 은탄환(one seeks bullets of silver)은 한번에 무력화 시킬 수 있는 최고의 도구이다.
    - [1986년 프레드 브룩스가 쓴 소프트웨어 공학 논문](http://worrydream.com/refs/Brooks-NoSilverBullet.pdf)에서 은탄환의 존재에 대해 최초로 언급하였다. 이와 동시에 소프트웨어 개발의 복잡성을 한번에 해소할 마법같은 솔루션(은탄환)은 없다고 선언한다.
    - 우리의 설계에는 Best라는 것은 없다. 항상 Better을 목표로 할 뿐이다.
        - 항상 제일 좋은 코드가 무엇인가를 생각하면서 짰었는데, 나의 입장에서 최대한 한 발자국이라도 더 나아갔다면 그걸로 ok…입니다…

### 10. 이름 설계 : 구조를 파악할 수 있는 이름

- 악마를 불러들이는 이름
    ![image](https://github.com/taeyun1215/BookReview/assets/65766105/d62c3c8c-39ff-4ae5-9391-e2d9fee20bd6)
    - 온라인 쇼핑몰은 상품을 중심으로 이루어져있다.
    - 따라서 이름을 단순하게 상품 클래스라고 붙이, 여러 유스케이스와 관계를 맺게 된다.
    - 그러면 상품 클래스가 여러 클래스와 관련 로직을 갖게 되어 결합도가 높아진다.
        ![image](https://github.com/taeyun1215/BookReview/assets/65766105/92da022c-d746-45f3-bbb9-39b0b537560f)
- 관심사 분리
    - 상품이 예약, 주문, 발송등 다양한 관심사에 관한 로직을 갖고 있다. → 강합 결합 상태
    - 강한 결합을 해소시키기 위해 관심사 분리를 해야한다.
    - 관심사 분리란 관심사(유스케이스, 목적, 역할)에 따라서 분리한다.
         ![image](https://github.com/taeyun1215/BookReview/assets/65766105/b6b5b820-8034-48ee-98fa-f7141b4c70a8)
    - 분할 후에는 분할한 클래스 각각에 관심사에 맞는 로직을 캡슐화하면 된다.
    - 이렇게 관심사 분리를 하면 결합도를 낮추고 응집도를 높힐수 있다.
    - 또한, 주문에 대한 로직이 변경 되었을 경우 주문과 관련된 클래스만 확인하면 되기에 개발 생산성이 향상될 것이다.
- 이름 설계하기
    - 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기
    - 존재보단 목적 기반의 이름 생각하기
    - 어떤 관심사를 가졌는지 분석하기
    - 소리 내어 이야기해보기
    - 대체 이름 생각해보기
    - 결합이 느슨하고 응집도가 높은 구조인지 검토하기
- 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기
    - 안 좋은 예시
        
        ```java
        class OrderService {
            public void add(Order o) { /*...*/ }
            public void update(Order o) { /*...*/ }
            public void get(int id) { /*...*/ }
            public void del(int id) { /*...*/ }
        }
        ```
        
    - 좋은 예시
        
        ```java
        class OrderService {
            public void addNewOnlineOrder(Order onlineOrder) { /*...*/ }
            public void updateUnshippedOrder(Order unshippedOrder) { /*...*/ }
            public void retrieveOrderById(int orderId) { /*...*/ }
            public void deleteCanceledOrder(int canceledOrderId) { /*...*/ }
        }
        ```
        
        - 메소드 명만 보더라도 이 메소드가 어떤 작업을 하는지 이해할 수 있다.
    - 더 좋은 예시
        
        ```java
        // 주문 생성과 관련된 로직만 담당하는 서비스
        class OrderCreationService {
            public void addNewOnlineOrder(Order onlineOrder) {
                // 온라인 주문 추가 로직
            }
        }
        
        // 주문 상태와 관련된 업데이트 로직만 담당하는 서비스
        class OrderUpdateService {
            public void updateUnshippedOrder(Order unshippedOrder) {
                // 발송되지 않은 주문 업데이트 로직
            }
        
            public void deleteCanceledOrder(int canceledOrderId) {
                // 취소된 주문 삭제 로직
            }
        }
        
        // 주문 조회와 관련된 로직만 담당하는 서비스
        class OrderRetrievalService {
            public Order retrieveOrderById(int orderId) {
                // 주문 ID를 통한 주문 조회 로직
                return new Order(); // 예시입니다. 실제 로직에 따라 변경이 필요합니다.
            }
        }
        ```
        
        - 이렇게 서비스를 세분화하면 각 서비스는 자신의 주된 책임에만 집중하게 된다.
        - 또한, 클래스의 크기가 줄어들어 관리하기 쉬워집니다.
