# 내 코드가 그렇게 이상한가요?

### 1. 잘못된 구조의 문제 깨닫기

- 의미를 알수 없는 네이밍은 지향하자
    - 클래스, 메소드 등에 번호를 붙히지 않고 어떤 작업을 하는지 기술 중심에 명명법으로 사용하자
- 이해하기 어럽게 많든 조건문은 지향하자
    - 예를들어 if문이 하나의 비즈니스 로직에 적게는 5개 많게는 수십개가 들어간 코드를 만들지 말자
- 데이터 클래스
    - 데이터 밖에 없는 클래스는 다른 클래스에 의해 핸들링 된다.
    - 하지만 다른 클래스 1개가 아닌 여러 클래스에 핸들링 된다.
    - 이러한 상황은 데이터를 담고 있는 클래스와 데이터를 사용해서 계산하는 클래스가 떨어져 있을 경우를 응집도가 낮은 구조라고 한다.
    - 아래는 응집도가 낮으면 생기는 문제점들을 나열했다.
        1. 코드 중복 : 데이터 클래스를 의존하는 여러 클래스 모두 중복된 코드를 갖게 됨.
        2. 수정 누락 : 비즈니스 로직이 변경 된다면 여러 클래스들은 모두 코드 수정이 불가피 할 것이다. 코드가 많아지면 놓치는 부분이 존재할 수도 있을 것이다.
        3. 잘못된 값 할당 : 데이터 클래스에 유효성 검사가 따로 없기에 모든 유효성 검사는 데이터 클래스를 의존하는 여러 클래스는 모두 유효성 검사를 해줘야한다.
- 응집도와 결합도
    - 응집도
        - 멍청한 이야기지만…나는 여태 응집도랑 결합도가 거의 유사한 개념이라고 생각했었다.
        - 응집도는 하나의 모듈 또는 클래스 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타낸다.
        - 높은 응집도는 클래스나 모듈의 모든 메서드와 속성이 단일 목적 또는 기능에 집중되어 있다는 것을 의미한다.
        - 예를 들어, **`OrderService`** 클래스가 **`Order`** 클래스의 내부 필드에 직접 접근하고 있다. 두 클래스 사이의 결합도는 높다고 볼 수 있다.
            
            ```java
            public class Order {
                public double price;
                public int quantity;
            
                public double getTotalPrice() {
                    return price * quantity;
                }
            }
            
            public class OrderService {
                public void printOrderTotalPrice(Order order) {
                    // 직접 Order 클래스의 내부 구조에 접근
                    System.out.println(order.price * order.quantity);
                }
            }
            ```
            
    - 결합도
        - 결합도는 두 모듈 또는 클래스가 서로 얼마나 강하게 연결되어 있는지를 나타낸다.
        - 낮은 결합도는 각 클래스나 모듈이 독립적이며, 다른 클래스나 모듈의 내부 구현에 대한 지식 없이도 변경이나 확장이 가능하다는 것을 의미한다.
        - 예를 들어, **`OrderService`** 클래스가 **`Order`** 클래스의 메서드만 호출하고, **`Order`** 클래스의 내부 구조나 로직에 의존하지 않는다면, 두 클래스 사이의 결합도는 낮다고 볼 수 있다.
            
            ```java
            public class Order {
                private double price;
                private int quantity;
            
                public double getTotalPrice() {
                    return price * quantity;
                }
            }
            
            public class OrderService {
                public void printOrderTotalPrice(Order order) {
                    // Order 클래스의 제공하는 메서드만 사용
                    System.out.println(order.getTotalPrice());
                }
            }
            ```
            
    - 응집도가 높고 결합도가 낮은 설계의 장점
        - 유지 보수성 : 각 컴포넌트나 모듈이 독립적이므로, 한 부분을 수정하거나 확장해도 다른 부분에 미치는 영향이 최소화된다.
        - 재사용성: 응집도가 높은 컴포넌트나 모듈은 특정 기능에 집중하기 때문에 다른 프로젝트나 문맥에서도 재사용하기 쉽다.
        - 확장성: 결합도가 낮은 설계는 새로운 기능이나 요구 사항을 추가할 때 유연성을 가진다.
    
    ### 2. 설계 첫 걸음
    
    - 의도를 분명히 전달할 수 있는 이름 설계하기
    - 변수를 계속해서 재할당 하는것이 아닌 목적별로 변수를 따로 생성하기
        - 가독성 저하: 변수의 값이 여러 번 바뀌면 코드를 읽는 사람이 그 변수의 현재 값이 무엇인지 추적하기 어려워진다.
        - **불변성 손실**: 불변성(Immutability)은 데이터의 안정성을 보장하고 함수형 프로그래밍 패러다임에서 중요하게 여겨진다. 재할당을 많이 사용하면 불변성을 유지하기 어려워진다.
        - **리팩토링 어려움**: 변수가 재할당되는 코드는 리팩토링이나 코드의 수정이 필요할 때 변경의 범위를 예측하기 어려워진다.
    - 데이터와 로직이 묶여 있는 좋은 클래스
        
        ```java
        class OrderItem {
            private String productName;
            private double price;
            private int quantity;
        
            public OrderItem(String productName, double price, int quantity) {
                if (price < 0) {
                    throw new IllegalArgumentException("Price cannot be negative");
                }
                if (quantity < 0) {
                    throw new IllegalArgumentException("Quantity cannot be negative");
                }
        
                this.productName = productName;
                this.price = price;
                this.quantity = quantity;
            }
        
            // 해당 품목의 총 가격을 계산
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        }
        ```
        
        - 생성자를 통해 유효성 검사를 완료하였다.
        - `calculateTotalPriceForItem` → 메소드 명만 확인해도 해당 품목의 총 가격을 계산하는 로직인 걸 알수 있다.

### 3. 클래스 설계 : 모든 것과 연결되는 설계 기반

- 잘 만들어진 클래스는 두가지로 구성 되어야한다.
    1. 인스턴스 변수
        - 객체가 생성될 때마다 독립적인 메모리 공간을 갖게 되는 변수이다.
        - Java에서는 접근 제한자로 `Private`, `Public`, `Protected`로 사용되며 일반적으로 캡슐화 원칙에 따라 **`private`**로 설정되어 외부로부터 직접 접근이 제한된다.
    2. 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메소드
        - 이는 캡슐화 원칙의 일환이다. 캡슐화는 객체의 상태를 외부에서 직접 변경하지 못하게 하고, 대신 정해진 메서드를 통해서만 상태를 변경하도록 제한하는 원칙이다.
        - 예를 들어, 인스턴스 변수가 `private`로 선언되었다면, 해당 변수를 직접 조작할 수 없다. 대신, 이 변수의 값을 조회하거나 변경하기 메서드를 사용한다.
- 모든 클래스가 갖추어야 하는 자기 방어 임무
    - 다른 클래스를 사용해서 초기화와 유효성 검사를 해야 하는 클래스는 그 자체로는 안전하게 사용할 수 없는 미성숙한 클래스이다.
    - 클래스는 스스로 자기 방어 임무(혼자서 초기화와 유효성 검사 가능해야 함)를 수행할 수 있어야 소프트웨어의 품질을 높이는 데 도움이 된다.
- 성숙한 클래스로 성장시키는 설계 기법
    - 잘못된 값을 들어간 인스턴스가 생성되지 못하게 생성자를 통해 유효성을 검사한다.
        
        ```java
        class OrderItem {
            private String productName;
            private double price;
            private int quantity;
        
            public OrderItem(String productName, double price, int quantity) {
                if (price < 0) {
                    throw new IllegalArgumentException("Price cannot be negative");
                }
                if (quantity < 0) {
                    throw new IllegalArgumentException("Quantity cannot be negative");
                }
        
                this.productName = productName;
                this.price = price;
                this.quantity = quantity;
            }
        }
        ```
        
    - 불변 변수로 만들어 예상하지 못한 동작 막기
        
        ```java
        class OrderItem {
            private final String productName;
            private final double price;
            private final int quantity;
        
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        }
        ```
        
        - 이렇게 되면 생성자를 통해서만 생성이 가능하다.
    - 값을 변경하고 싶다면 새로운 인스턴스 만들기
        
        ```java
        class OrderItem {
            private final String productName;
            private final double price;
            private final int quantity;
        
            public double calculateTotalPriceForItem() {
                return price * quantity;
            }
        
            public OrderItem updatedQuantity(int newQuantity) {
                return new OrderItem(productName, price, newQuantity);
            }
        }
        ```
        
        - 이렇게 하면 불변을 유지하면서도 값을 변경할 수 있다.
- 위와 마찬가지로 메소드의 매개변수, 지역 변수도 불변으로 만들수 있다.
- 값 객체
    - 값 객체란 값을 클래스(자료형)로 나타내는 디자인 패턴이다.
    - 금액, 날짜 등을 사용하게 되면 각각의 값과 로직이 있기에 응집도가 높은 구조로 만들 수 있다.
    - 예를 들어 금액을 단순한 int형으로 두었다면 상품의 개수 가격등에 사용이 되며 실수로 의미가 다른 값이 섞을수도 있다.
    - 값 객체 + 완전 생성자는 객체 지향 설계에서 많이 사용되는 기법이다.
